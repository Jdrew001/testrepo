import { Directive, Host, OnInit, AfterViewInit } from '@angular/core';
import { Table } from 'primeng/table';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, AfterViewInit {

  constructor(@Host() private table: Table) {}

  ngOnInit() {
    // Store original method
    const originalToggleRowsWithCheckbox = (this.table as any).toggleRowsWithCheckbox;
    
    // Override the internal toggle method
    (this.table as any).toggleRowsWithCheckbox = (event: any, check: boolean) => {
      const data = this.table.filteredValue || this.table.value || [];
      if (!data.length) return;

      // Filter out disabled items
      const selectableItems = data.filter(item => !this.isDisabled(item));
      
      if (check) {
        // Select all enabled items
        this.table.selection = [...selectableItems];
      } else {
        // Clear selection
        this.table.selection = [];
      }

      // Update selection keys
      this.updateSelectionKeys();
      
      // Emit events
      this.table.onHeaderCheckboxToggle.emit({ originalEvent: event, checked: check });
      if (this.table.selectionChange) {
        this.table.selectionChange.emit(this.table.selection);
      }
    };

    // Override the header checkbox state check
    const originalIsAllRowsSelected = (this.table as any).isAllRowsSelected;
    (this.table as any).isAllRowsSelected = () => {
      const data = this.table.filteredValue || this.table.value || [];
      if (!data.length) return false;
      
      const selectableItems = data.filter(item => !this.isDisabled(item));
      if (!selectableItems.length) return false;
      
      if (!this.table.selection || !Array.isArray(this.table.selection)) return false;
      
      return selectableItems.every(item => 
        this.table.selection.some(selected => this.equals(item, selected))
      );
    };
  }

  ngAfterViewInit() {
    // Clean up selection on init
    setTimeout(() => this.cleanSelection(), 0);
    
    // Monitor for header being disabled
    setInterval(() => this.keepHeaderEnabled(), 100);
  }

  private keepHeaderEnabled() {
    const headerCheckbox = (this.table as any).headerCheckbox;
    if (headerCheckbox && (this.table.value?.length > 0)) {
      if (headerCheckbox.disabled) {
        headerCheckbox.disabled = false;
      }
    }
  }

  private cleanSelection() {
    if (!this.table.selection || !Array.isArray(this.table.selection)) return;
    
    const data = this.table.filteredValue || this.table.value || [];
    const selectableItems = data.filter(item => !this.isDisabled(item));
    
    const cleaned = this.table.selection.filter(selected =>
      selectableItems.some(item => this.equals(item, selected))
    );
    
    if (cleaned.length !== this.table.selection.length) {
      this.table.selection = cleaned;
      this.updateSelectionKeys();
    }
  }

  private updateSelectionKeys() {
    // Always use entityId + entityType as the composite key
    const keys: any = {};
    if (Array.isArray(this.table.selection)) {
      this.table.selection.forEach(item => {
        if (item.entityId !== undefined && item.entityType !== undefined) {
          const compositeKey = `${item.entityType}_${item.entityId}`;
          keys[compositeKey] = 1;
        }
      });
    }
    (this.table as any).selectionKeys = keys;
  }

  private isDisabled(item: any): boolean {
    return item.disabled === true || item.selectable === false;
  }

  private equals(a: any, b: any): boolean {
    if (a === b) return true;
    if (!a || !b) return false;
    
    // Always use entityId + entityType for comparison
    if (a.entityId !== undefined && a.entityType !== undefined &&
        b.entityId !== undefined && b.entityType !== undefined) {
      return a.entityId === b.entityId && a.entityType === b.entityType;
    }
    
    return false;
  }

  private resolveFieldData(data: any, field: string): any {
    // For composite key, always return entityType_entityId
    if (data.entityId !== undefined && data.entityType !== undefined) {
      return `${data.entityType}_${data.entityId}`;
    }
    
    if (field.indexOf('.') === -1) return data[field];
    
    const fields = field.split('.');
    let value = data;
    for (const f of fields) {
      if (value == null) return null;
      value = value[f];
    }
    return value;
  }
}
