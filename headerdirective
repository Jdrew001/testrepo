import { Directive, Host, OnInit, OnDestroy, AfterViewInit, ElementRef } from '@angular/core';
import { Table } from 'primeng/table';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, OnDestroy, AfterViewInit {
  
  private destroy$ = new Subject<void>();
  private headerCheckboxClickListener?: (event: Event) => void;

  constructor(
    @Host() private table: Table,
    private element: ElementRef
  ) {}

  ngOnInit() {
    // Monitor selection changes to clean up disabled items
    if (this.table.selectionChange) {
      this.table.selectionChange
        .pipe(takeUntil(this.destroy$))
        .subscribe(() => {
          setTimeout(() => this.cleanupDisabledItems(), 0);
        });
    }
  }

  ngAfterViewInit() {
    // Override header checkbox behavior
    setTimeout(() => {
      this.setupHeaderCheckboxOverride();
      this.updateHeaderCheckboxState();
    }, 100);
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    
    if (this.headerCheckboxClickListener) {
      const headerCheckbox = this.getHeaderCheckbox();
      if (headerCheckbox) {
        headerCheckbox.removeEventListener('click', this.headerCheckboxClickListener);
      }
    }
  }

  private setupHeaderCheckboxOverride() {
    const headerCheckbox = this.getHeaderCheckbox();
    if (!headerCheckbox) return;

    // Remove existing listeners and add our own
    const newCheckbox = headerCheckbox.cloneNode(true) as HTMLInputElement;
    headerCheckbox.parentNode?.replaceChild(newCheckbox, headerCheckbox);

    this.headerCheckboxClickListener = (event: Event) => {
      setTimeout(() => {
        this.handleHeaderCheckboxClick(newCheckbox);
      }, 0);
    };

    newCheckbox.addEventListener('click', this.headerCheckboxClickListener);
  }

  private handleHeaderCheckboxClick(checkbox: HTMLInputElement) {
    if (checkbox.checked) {
      // Select only enabled items
      this.selectEnabledItemsOnly();
      // Force header checkbox to stay checked
      setTimeout(() => {
        checkbox.checked = true;
        if ('indeterminate' in checkbox) {
          checkbox.indeterminate = false;
        }
      }, 0);
    } else {
      // Deselect all
      this.table.selection = [];
      this.table.selectionChange.emit([]);
    }
  }

  private selectEnabledItemsOnly() {
    if (!this.table.value) return;

    const enabledItems: any[] = [];
    const bodyCheckboxes = this.getBodyCheckboxes();

    bodyCheckboxes.forEach((checkbox, index) => {
      if (!checkbox.disabled && this.table.value[index]) {
        enabledItems.push(this.table.value[index]);
      }
    });

    this.table.selection = enabledItems;
    this.table.selectionChange.emit(enabledItems);

    // Manually check the body checkboxes for enabled items
    bodyCheckboxes.forEach((checkbox, index) => {
      if (!checkbox.disabled && this.table.value[index]) {
        checkbox.checked = true;
      }
    });

    // Update header checkbox state
    setTimeout(() => {
      this.updateHeaderCheckboxState();
    }, 0);
  }

  private cleanupDisabledItems() {
    if (!this.table.selection?.length) return;

    const bodyCheckboxes = this.getBodyCheckboxes();
    const enabledItems: any[] = [];

    // Collect only items that have enabled checkboxes
    bodyCheckboxes.forEach((checkbox, index) => {
      if (!checkbox.disabled && this.table.value?.[index]) {
        enabledItems.push(this.table.value[index]);
      }
    });

    // Filter selection to only include enabled items
    const validSelection = this.table.selection.filter(item => 
      enabledItems.some(enabledItem => this.itemsEqual(item, enabledItem))
    );

    if (validSelection.length !== this.table.selection.length) {
      this.table.selection = validSelection;
      this.table.selectionChange.emit(validSelection);

      // Uncheck any disabled checkboxes that might be checked
      bodyCheckboxes.forEach((checkbox, index) => {
        if (checkbox.disabled) {
          checkbox.checked = false;
        }
      });

      // Update header checkbox state
      setTimeout(() => {
        this.updateHeaderCheckboxState();
      }, 0);
    }
  }

  private updateHeaderCheckboxState() {
    const headerCheckbox = this.getHeaderCheckbox();
    if (!headerCheckbox) return;

    const bodyCheckboxes = this.getBodyCheckboxes();
    let enabledCount = 0;
    let selectedEnabledCount = 0;

    bodyCheckboxes.forEach(checkbox => {
      if (!checkbox.disabled) {
        enabledCount++;
        if (checkbox.checked) {
          selectedEnabledCount++;
        }
      }
    });

    if (enabledCount === 0) {
      // No enabled checkboxes
      headerCheckbox.checked = false;
      if ('indeterminate' in headerCheckbox) {
        headerCheckbox.indeterminate = false;
      }
    } else if (selectedEnabledCount === enabledCount) {
      // All enabled items are selected
      headerCheckbox.checked = true;
      if ('indeterminate' in headerCheckbox) {
        headerCheckbox.indeterminate = false;
      }
    } else if (selectedEnabledCount > 0) {
      // Some enabled items are selected
      headerCheckbox.checked = false;
      if ('indeterminate' in headerCheckbox) {
        headerCheckbox.indeterminate = true;
      }
    } else {
      // No items are selected
      headerCheckbox.checked = false;
      if ('indeterminate' in headerCheckbox) {
        headerCheckbox.indeterminate = false;
      }
    }
    }
  }

  private getHeaderCheckbox(): HTMLInputElement | null {
    const selectors = [
      'thead p-tableheadercheckbox input',
      'thead .p-checkbox input',
      'thead input[type="checkbox"]'
    ];

    for (const selector of selectors) {
      const element = this.element.nativeElement.querySelector(selector);
      if (element) return element as HTMLInputElement;
    }

    return null;
  }

  private getBodyCheckboxes(): HTMLInputElement[] {
    const selectors = [
      'tbody p-tablecheckbox input',
      'tbody .p-checkbox input', 
      'tbody input[type="checkbox"]'
    ];

    for (const selector of selectors) {
      const elements = this.element.nativeElement.querySelectorAll(selector);
      if (elements.length > 0) {
        return Array.from(elements) as HTMLInputElement[];
      }
    }

    return [];
  }

  private itemsEqual(item1: any, item2: any): boolean {
    if (item1 === item2) return true;
    
    // Try to compare by common ID properties
    const idProps = ['id', 'ID', '_id', 'key', 'uuid'];
    for (const prop of idProps) {
      if (item1?.[prop] && item2?.[prop]) {
        return item1[prop] === item2[prop];
      }
    }
    
    return false;
  }
}
