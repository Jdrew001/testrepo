import { Directive, Host, OnInit, OnDestroy, AfterViewInit, ElementRef, Renderer2, NgZone } from '@angular/core';
import { Table } from 'primeng/table';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, OnDestroy, AfterViewInit {
  
  private destroy$ = new Subject<void>();
  private headerCheckboxClickListener?: (event: Event) => void;
  private headerCheckboxMonitorInterval?: any;
  private lastKnownHeaderState = { checked: false, indeterminate: false };
  private isProcessingHeaderClick = false;

  constructor(
    @Host() private table: Table,
    private element: ElementRef,
    private renderer: Renderer2,
    private ngZone: NgZone
  ) {}

  ngOnInit() {
    // Monitor selection changes to clean up disabled items
    if (this.table.selectionChange) {
      this.table.selectionChange
        .pipe(takeUntil(this.destroy$))
        .subscribe(() => {
          // Don't update if we're processing a header click
          if (!this.isProcessingHeaderClick) {
            setTimeout(() => {
              this.cleanupDisabledItems();
              this.updateHeaderCheckboxState();
            }, 0);
          }
        });
    }

    // Override PrimeNG's header checkbox toggle completely
    this.overridePrimeNGBehavior();
  }

  ngAfterViewInit() {
    // Initial setup
    setTimeout(() => {
      this.setupHeaderCheckboxControl();
      this.updateHeaderCheckboxState();
      this.uncheckDisabledCheckboxes();
      
      // Start aggressive monitoring to keep header enabled
      this.startHeaderMonitoring();
    }, 100);

    // Handle table updates
    [this.table.onPage, this.table.onSort, this.table.onFilter].forEach(event => {
      if (event) {
        event.pipe(takeUntil(this.destroy$)).subscribe(() => {
          setTimeout(() => {
            this.setupHeaderCheckboxControl();
            this.updateHeaderCheckboxState();
            this.uncheckDisabledCheckboxes();
          }, 100);
        });
      }
    });

    // Also monitor for lazy loading if applicable
    if (this.table.onLazyLoad) {
      this.table.onLazyLoad.pipe(takeUntil(this.destroy$)).subscribe(() => {
        setTimeout(() => {
          this.setupHeaderCheckboxControl();
          this.updateHeaderCheckboxState();
          this.uncheckDisabledCheckboxes();
        }, 100);
      });
    }
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    
    // Clean up monitoring
    if (this.headerCheckboxMonitorInterval) {
      clearInterval(this.headerCheckboxMonitorInterval);
    }
    
    // Clean up listeners
    this.removeHeaderCheckboxListeners();
  }

  private overridePrimeNGBehavior() {
    // Completely override PrimeNG's toggle all functionality
    if (this.table) {
      // Override the toggleAll method if it exists
      const originalToggleAll = (this.table as any).toggleAll;
      if (originalToggleAll) {
        (this.table as any).toggleAll = (event: any) => {
          // Don't call the original, handle it ourselves
          this.handleCustomToggleAll();
          return false;
        };
      }

      // Override onHeaderCheckboxToggle emission
      if (this.table.onHeaderCheckboxToggle) {
        const originalEmit = this.table.onHeaderCheckboxToggle.emit;
        this.table.onHeaderCheckboxToggle.emit = (event: any) => {
          // Prevent default behavior completely
          if (event) {
            event.preventDefault?.();
            event.stopPropagation?.();
            event.stopImmediatePropagation?.();
          }
          // Handle our custom logic instead
          this.handleCustomToggleAll();
          return false;
        };
      }

      // Override isAllRowsSelected if it exists
      const originalIsAllRowsSelected = (this.table as any).isAllRowsSelected;
      if (originalIsAllRowsSelected) {
        (this.table as any).isAllRowsSelected = () => {
          const enabledItems = this.getEnabledItems();
          if (enabledItems.length === 0) return false;
          return enabledItems.every(item => this.isItemSelected(item));
        };
      }

      // Also override the internal updateSelection method
      const originalUpdateSelection = (this.table as any).updateSelection;
      if (originalUpdateSelection) {
        (this.table as any).updateSelection = (event: any, data: any) => {
          // Only allow individual row selections
          if (event?.target && !event.target.closest('thead')) {
            originalUpdateSelection.call(this.table, event, data);
          }
        };
      }
    }
  }

  private startHeaderMonitoring() {
    // Aggressively monitor and fix header checkbox state every 50ms
    this.ngZone.runOutsideAngular(() => {
      this.headerCheckboxMonitorInterval = setInterval(() => {
        const headerCheckbox = this.getHeaderCheckbox();
        if (headerCheckbox) {
          // Force enable if disabled
          if (headerCheckbox.disabled) {
            this.ngZone.run(() => {
              headerCheckbox.disabled = false;
              const pCheckbox = headerCheckbox.closest('.p-checkbox');
              if (pCheckbox) {
                pCheckbox.classList.remove('p-checkbox-disabled', 'p-disabled');
                const box = pCheckbox.querySelector('.p-checkbox-box');
                if (box) {
                  box.classList.remove('p-disabled');
                }
              }
            });
          }
          
          // Also check if PrimeNG has messed with our checkbox element
          const hasOurListener = (headerCheckbox as any).__ourListenerAttached;
          if (!hasOurListener) {
            this.ngZone.run(() => {
              this.setupHeaderCheckboxControl();
            });
          }
        }
      }, 50);
    });
  }

  private setupHeaderCheckboxControl() {
    this.removeHeaderCheckboxListeners();
    
    const headerCheckbox = this.getHeaderCheckbox();
    if (!headerCheckbox) {
      setTimeout(() => this.setupHeaderCheckboxControl(), 50);
      return;
    }

    // Force enable
    headerCheckbox.disabled = false;
    
    // Mark that we're attaching our listener
    (headerCheckbox as any).__ourListenerAttached = true;
    
    // Remove all existing event listeners by cloning
    const parent = headerCheckbox.parentNode;
    if (parent) {
      const newCheckbox = headerCheckbox.cloneNode(true) as HTMLInputElement;
      newCheckbox.disabled = false;
      (newCheckbox as any).__ourListenerAttached = true;
      parent.replaceChild(newCheckbox, headerCheckbox);
      
      // Ensure visual state is correct
      const pCheckbox = newCheckbox.closest('.p-checkbox');
      if (pCheckbox) {
        pCheckbox.classList.remove('p-checkbox-disabled', 'p-disabled');
      }

      // Attach our single click handler to the new checkbox
      this.attachHeaderCheckboxListener(newCheckbox);
      
      // Also intercept clicks on the p-checkbox wrapper
      if (pCheckbox) {
        pCheckbox.addEventListener('click', (e) => {
          if (e.target !== newCheckbox) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            newCheckbox.click();
          }
        }, true);
      }
    }
  }

  private attachHeaderCheckboxListener(headerCheckbox: HTMLInputElement) {
    this.headerCheckboxClickListener = (event: Event) => {
      event.preventDefault();
      event.stopPropagation();
      event.stopImmediatePropagation();
      
      // Set flag to prevent circular updates
      this.isProcessingHeaderClick = true;
      
      // Handle the toggle
      this.handleCustomToggleAll();
      
      // Clear flag after processing
      setTimeout(() => {
        this.isProcessingHeaderClick = false;
      }, 100);
      
      // Return false to prevent any other handlers
      return false;
    };

    // Add listener with capture to intercept before anything else
    headerCheckbox.addEventListener('click', this.headerCheckboxClickListener, true);
    
    // Also prevent mousedown/mouseup to be extra sure
    const preventEvent = (e: Event) => {
      e.stopPropagation();
      e.stopImmediatePropagation();
    };
    
    headerCheckbox.addEventListener('mousedown', preventEvent, true);
    headerCheckbox.addEventListener('mouseup', preventEvent, true);
  }

  private handleCustomToggleAll() {
    const headerCheckbox = this.getHeaderCheckbox();
    if (!headerCheckbox) return;

    // Get current state
    const enabledItems = this.getEnabledItems();
    const selectedEnabledItems = enabledItems.filter(item => this.isItemSelected(item));
    
    // Determine action based on current selection state
    let shouldSelectAll = false;
    
    if (selectedEnabledItems.length === 0) {
      // Nothing selected -> select all
      shouldSelectAll = true;
    } else if (selectedEnabledItems.length < enabledItems.length) {
      // Partially selected -> select all
      shouldSelectAll = true;
    } else {
      // All selected -> deselect all
      shouldSelectAll = false;
    }

    // Apply the action
    if (shouldSelectAll) {
      // Select only enabled items
      this.table.selection = [...enabledItems];
    } else {
      // Deselect all
      this.table.selection = [];
    }

    // Emit the change
    if (this.table.selectionChange) {
      this.table.selectionChange.emit(this.table.selection);
    }

    // Update visual states immediately
    this.updateBodyCheckboxes();
    
    // Update header state after a brief delay
    setTimeout(() => {
      this.updateHeaderCheckboxState();
    }, 20);
  }

  private removeHeaderCheckboxListeners() {
    const headerCheckbox = this.getHeaderCheckbox();
    if (headerCheckbox) {
      // Mark as not having our listener
      (headerCheckbox as any).__ourListenerAttached = false;
      
      if (this.headerCheckboxClickListener) {
        headerCheckbox.removeEventListener('click', this.headerCheckboxClickListener, true);
      }
    }
  }

  private getEnabledItems(): any[] {
    if (!this.table.value) return [];

    const enabledItems: any[] = [];
    const bodyCheckboxes = this.getBodyCheckboxes();

    // Use the actual checkbox disabled state as the source of truth
    if (bodyCheckboxes.length > 0) {
      this.table.value.forEach((item, index) => {
        const checkbox = bodyCheckboxes[index];
        if (checkbox && !checkbox.disabled) {
          enabledItems.push(item);
        }
      });
    } else {
      // If no checkboxes rendered yet, return all items
      return [...this.table.value];
    }

    return enabledItems;
  }

  private updateBodyCheckboxes() {
    const bodyCheckboxes = this.getBodyCheckboxes();
    
    bodyCheckboxes.forEach((checkbox, index) => {
      const item = this.table.value?.[index];
      if (!item) return;
      
      if (checkbox.disabled) {
        // Force disabled checkboxes to be unchecked
        checkbox.checked = false;
        checkbox.indeterminate = false;
        
        // Update visual state
        const pCheckbox = checkbox.closest('.p-checkbox');
        if (pCheckbox) {
          const box = pCheckbox.querySelector('.p-checkbox-box');
          if (box) {
            box.classList.remove('p-highlight');
            const icon = box.querySelector('.p-checkbox-icon');
            if (icon) {
              icon.classList.remove('pi-check', 'pi-minus');
            }
          }
        }
      } else {
        // Update enabled checkbox based on selection
        const isSelected = this.isItemSelected(item);
        checkbox.checked = isSelected;
        checkbox.indeterminate = false;
        
        // Update visual state
        const pCheckbox = checkbox.closest('.p-checkbox');
        if (pCheckbox) {
          const box = pCheckbox.querySelector('.p-checkbox-box');
          if (box) {
            if (isSelected) {
              box.classList.add('p-highlight');
              const icon = box.querySelector('.p-checkbox-icon');
              if (icon) {
                icon.classList.add('pi', 'pi-check');
                icon.classList.remove('pi-minus');
              }
            } else {
              box.classList.remove('p-highlight');
              const icon = box.querySelector('.p-checkbox-icon');
              if (icon) {
                icon.classList.remove('pi-check', 'pi-minus');
              }
            }
          }
        }
      }
    });
  }

  private uncheckDisabledCheckboxes() {
    const bodyCheckboxes = this.getBodyCheckboxes();
    bodyCheckboxes.forEach(checkbox => {
      if (checkbox.disabled) {
        checkbox.checked = false;
        checkbox.indeterminate = false;
        const pCheckbox = checkbox.closest('.p-checkbox');
        if (pCheckbox) {
          const box = pCheckbox.querySelector('.p-checkbox-box');
          if (box) {
            box.classList.remove('p-highlight');
            const icon = box.querySelector('.p-checkbox-icon');
            if (icon) {
              icon.classList.remove('pi-check', 'pi-minus');
            }
          }
        }
      }
    });
  }

  private cleanupDisabledItems() {
    if (!this.table.selection || !Array.isArray(this.table.selection) || this.table.selection.length === 0) {
      return;
    }

    const enabledItems = this.getEnabledItems();
    const validSelection = this.table.selection.filter(item => 
      enabledItems.some(enabledItem => this.itemsEqual(item, enabledItem))
    );

    if (validSelection.length !== this.table.selection.length) {
      this.table.selection = validSelection;
      if (this.table.selectionChange) {
        this.table.selectionChange.emit(validSelection);
      }
    }

    this.uncheckDisabledCheckboxes();
  }

  private updateHeaderCheckboxState() {
    const headerCheckbox = this.getHeaderCheckbox();
    if (!headerCheckbox) return;

    // Get current selection state
    const enabledItems = this.getEnabledItems();
    const selectedEnabledCount = enabledItems.filter(item => this.isItemSelected(item)).length;
    const enabledCount = enabledItems.length;

    // CRITICAL: Force the header checkbox to be enabled no matter what
    headerCheckbox.disabled = false;
    
    // Determine the correct visual state
    let newChecked = false;
    let newIndeterminate = false;
    
    if (enabledCount === 0) {
      // No enabled items
      newChecked = false;
      newIndeterminate = false;
    } else if (selectedEnabledCount === 0) {
      // No selection
      newChecked = false;
      newIndeterminate = false;
    } else if (selectedEnabledCount === enabledCount) {
      // All enabled items selected
      newChecked = true;
      newIndeterminate = false;
    } else {
      // Partial selection
      newChecked = false;
      newIndeterminate = true;
    }

    // Apply the state to the checkbox
    headerCheckbox.checked = newChecked;
    headerCheckbox.indeterminate = newIndeterminate;
    
    // Store state for reference
    this.lastKnownHeaderState = { checked: newChecked, indeterminate: newIndeterminate };

    // Update visual state of p-checkbox wrapper
    const pCheckbox = headerCheckbox.closest('.p-checkbox');
    if (pCheckbox) {
      // Remove any disabled classes - this is critical
      pCheckbox.classList.remove('p-checkbox-disabled', 'p-disabled');
      
      const box = pCheckbox.querySelector('.p-checkbox-box');
      if (box) {
        // Remove disabled class from box
        box.classList.remove('p-disabled');
        
        // Clear all states first
        box.classList.remove('p-highlight');
        const icon = box.querySelector('.p-checkbox-icon');
        
        if (icon) {
          // Reset icon classes
          icon.className = 'p-checkbox-icon';
          
          if (newChecked) {
            box.classList.add('p-highlight');
            icon.classList.add('pi', 'pi-check');
          } else if (newIndeterminate) {
            box.classList.add('p-highlight');
            icon.classList.add('pi', 'pi-minus');
          } else {
            // Unchecked state - no icon
            icon.classList.add('pi');
          }
        }
      }
    }

    // Double-check the checkbox is still enabled after our updates
    if (headerCheckbox.disabled) {
      headerCheckbox.disabled = false;
    }
  }

  private isItemSelected(item: any): boolean {
    if (!this.table.selection) return false;
    
    if (Array.isArray(this.table.selection)) {
      return this.table.selection.some(selectedItem => 
        this.itemsEqual(item, selectedItem)
      );
    } else {
      return this.itemsEqual(item, this.table.selection);
    }
  }

  private getHeaderCheckbox(): HTMLInputElement | null {
    const selectors = [
      'thead p-tableheadercheckbox input[type="checkbox"]',
      'thead .p-selection-column input[type="checkbox"]',
      'thead .p-checkbox input[type="checkbox"]',
      'thead input[type="checkbox"][role="checkbox"]',
      'thead input[type="checkbox"]'
    ];

    for (const selector of selectors) {
      const element = this.element.nativeElement.querySelector(selector);
      if (element) return element as HTMLInputElement;
    }

    return null;
  }

  private getBodyCheckboxes(): HTMLInputElement[] {
    const selectors = [
      'tbody p-tablecheckbox input[type="checkbox"]',
      'tbody .p-selection-column input[type="checkbox"]',
      'tbody .p-checkbox input[type="checkbox"]',
      'tbody input[type="checkbox"][role="checkbox"]',
      'tbody input[type="checkbox"]'
    ];

    for (const selector of selectors) {
      const elements = this.element.nativeElement.querySelectorAll(selector);
      if (elements.length > 0) {
        return Array.from(elements) as HTMLInputElement[];
      }
    }

    return [];
  }

  private itemsEqual(item1: any, item2: any): boolean {
    if (item1 === item2) return true;
    if (!item1 || !item2) return false;
    
    // If table has a dataKey, use that for comparison
    if (this.table.dataKey) {
      const key1 = this.resolveFieldData(item1, this.table.dataKey);
      const key2 = this.resolveFieldData(item2, this.table.dataKey);
      if (key1 !== undefined && key2 !== undefined) {
        return key1 === key2;
      }
    }
    
    // Try common ID properties
    const idProps = ['id', 'ID', '_id', 'key', 'uuid', 'code'];
    for (const prop of idProps) {
      if (item1[prop] !== undefined && item2[prop] !== undefined) {
        return item1[prop] === item2[prop];
      }
    }
    
    // Fallback to reference equality
    return false;
  }

  private resolveFieldData(data: any, field: string): any {
    if (!data || !field) return undefined;
    
    if (field.indexOf('.') === -1) {
      return data[field];
    } else {
      const fields = field.split('.');
      let value = data;
      for (const f of fields) {
        if (value == null) return undefined;
        value = value[f];
      }
      return value;
    }
  }
}
