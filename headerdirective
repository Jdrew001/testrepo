import { Directive, Host, Input, OnInit, AfterViewInit } from '@angular/core';
import { Table } from 'primeng/table';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, AfterViewInit {

  @Input() selectableItems: any[] = [];

  constructor(@Host() private table: Table) {}

  ngOnInit() {
    // Override the internal toggle method
    (this.table as any).toggleRowsWithCheckbox = (event: any, check: boolean) => {
      const data = this.table.filteredValue || this.table.value || [];
      if (!data.length) return;

      // Filter to only selectable items
      const itemsToSelect = data.filter(item => this.isSelectable(item));
      
      if (check) {
        // Select all selectable items
        this.table.selection = [...itemsToSelect];
      } else {
        // Clear selection
        this.table.selection = [];
      }

      // Update selection keys
      this.updateSelectionKeys();
      
      // Emit events
      this.table.onHeaderCheckboxToggle.emit({ originalEvent: event, checked: check });
      if (this.table.selectionChange) {
        this.table.selectionChange.emit(this.table.selection);
      }
    };

    // Override the header checkbox state check
    (this.table as any).isAllRowsSelected = () => {
      const data = this.table.filteredValue || this.table.value || [];
      if (!data.length) return false;
      
      const selectableData = data.filter(item => this.isSelectable(item));
      if (!selectableData.length) return false;
      
      if (!this.table.selection || !Array.isArray(this.table.selection)) return false;
      
      return selectableData.every(item => 
        this.table.selection.some(selected => this.equals(item, selected))
      );
    };
  }

  ngAfterViewInit() {
    // Clean up selection on init
    setTimeout(() => this.cleanSelection(), 0);
    
    // Monitor for header being disabled
    setInterval(() => this.keepHeaderEnabled(), 100);
  }

  private keepHeaderEnabled() {
    const headerCheckbox = (this.table as any).headerCheckbox;
    if (headerCheckbox && (this.table.value?.length > 0)) {
      // Only enable if there are selectable items
      const hasSelectableItems = (this.table.value || []).some(item => this.isSelectable(item));
      headerCheckbox.disabled = !hasSelectableItems;
    }
  }

  private cleanSelection() {
    if (!this.table.selection || !Array.isArray(this.table.selection)) return;
    
    // Remove non-selectable items from selection
    const cleaned = this.table.selection.filter(selected => this.isSelectable(selected));
    
    if (cleaned.length !== this.table.selection.length) {
      this.table.selection = cleaned;
      this.updateSelectionKeys();
    }
  }

  private isSelectable(item: any): boolean {
    // If no selectableItems provided, everything is selectable
    if (!this.selectableItems || this.selectableItems.length === 0) {
      return true;
    }
    
    // Check if item is in the selectable list
    return this.selectableItems.some(selectable => this.equals(item, selectable));
  }

  private updateSelectionKeys() {
    const keys: any = {};
    if (Array.isArray(this.table.selection)) {
      this.table.selection.forEach(item => {
        if (item.entityId !== undefined && item.entityType !== undefined) {
          const compositeKey = `${item.entityType}_${item.entityId}`;
          keys[compositeKey] = 1;
        }
      });
    }
    (this.table as any).selectionKeys = keys;
  }

  private equals(a: any, b: any): boolean {
    if (a === b) return true;
    if (!a || !b) return false;
    
    // Always use entityId + entityType for comparison
    if (a.entityId !== undefined && a.entityType !== undefined &&
        b.entityId !== undefined && b.entityType !== undefined) {
      return a.entityId === b.entityId && a.entityType === b.entityType;
    }
    
    return false;
  }
}
