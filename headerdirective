import { Directive, Host, OnInit, OnDestroy, AfterViewInit, ElementRef, Renderer2, NgZone } from '@angular/core';
import { Table } from 'primeng/table';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, OnDestroy, AfterViewInit {
  
  private destroy$ = new Subject<void>();
  private headerCheckboxInterval?: any;
  private originalToggleAllFn?: Function;
  private isProcessingToggle = false;

  constructor(
    @Host() private table: Table,
    private element: ElementRef,
    private renderer: Renderer2,
    private ngZone: NgZone
  ) {}

  ngOnInit() {
    // Store the original toggleAll function
    this.originalToggleAllFn = (this.table as any).toggleAll?.bind(this.table);
    
    // Override the toggleAll method to filter disabled items
    if ((this.table as any).toggleAll) {
      (this.table as any).toggleAll = (event: any) => {
        this.customToggleAll(event);
      };
    }

    // Monitor selection changes
    if (this.table.selectionChange) {
      this.table.selectionChange
        .pipe(takeUntil(this.destroy$))
        .subscribe(() => {
          if (!this.isProcessingToggle) {
            requestAnimationFrame(() => {
              this.cleanupDisabledFromSelection();
              this.updateHeaderCheckbox();
            });
          }
        });
    }
  }

  ngAfterViewInit() {
    // Initial setup after view is ready
    setTimeout(() => {
      this.initializeHeaderFix();
    }, 100);

    // Re-initialize after table operations
    this.setupTableEventHandlers();
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    
    if (this.headerCheckboxInterval) {
      clearInterval(this.headerCheckboxInterval);
    }

    // Restore original function if needed
    if (this.originalToggleAllFn && (this.table as any).toggleAll) {
      (this.table as any).toggleAll = this.originalToggleAllFn;
    }
  }

  private setupTableEventHandlers() {
    // Re-initialize after pagination
    if (this.table.onPage) {
      this.table.onPage.pipe(takeUntil(this.destroy$)).subscribe(() => {
        // Use longer timeout for page changes to ensure DOM is ready
        setTimeout(() => {
          this.initializeHeaderFix();
        }, 200);
      });
    }

    // Re-initialize after sorting
    if (this.table.onSort) {
      this.table.onSort.pipe(takeUntil(this.destroy$)).subscribe(() => {
        setTimeout(() => {
          this.initializeHeaderFix();
        }, 150);
      });
    }

    // Re-initialize after filtering
    if (this.table.onFilter) {
      this.table.onFilter.pipe(takeUntil(this.destroy$)).subscribe(() => {
        setTimeout(() => {
          this.initializeHeaderFix();
        }, 150);
      });
    }

    // Handle lazy loading
    if (this.table.onLazyLoad) {
      this.table.onLazyLoad.pipe(takeUntil(this.destroy$)).subscribe(() => {
        setTimeout(() => {
          this.initializeHeaderFix();
        }, 200);
      });
    }
  }

  private initializeHeaderFix() {
    this.cleanupDisabledFromSelection();
    this.updateHeaderCheckbox();
    this.startHeaderMonitoring();
  }

  private startHeaderMonitoring() {
    // Clear any existing interval
    if (this.headerCheckboxInterval) {
      clearInterval(this.headerCheckboxInterval);
    }

    // Monitor header checkbox state
    this.ngZone.runOutsideAngular(() => {
      this.headerCheckboxInterval = setInterval(() => {
        const headerEl = this.getHeaderCheckboxElement();
        if (headerEl) {
          const checkbox = headerEl.querySelector('input[type="checkbox"]');
          if (checkbox && (checkbox as HTMLInputElement).disabled) {
            this.ngZone.run(() => {
              this.renderer.setProperty(checkbox, 'disabled', false);
              this.updateHeaderVisualState();
            });
          }
        }
      }, 100);
    });
  }

  private customToggleAll(event: any) {
    this.isProcessingToggle = true;

    // Get current page data
    const currentData = this.getCurrentPageData();
    
    // Get enabled items only
    const enabledItems = this.getEnabledItemsFromData(currentData);
    
    if (enabledItems.length === 0) {
      this.isProcessingToggle = false;
      return;
    }

    // Check current selection state
    const allEnabledSelected = enabledItems.every(item => this.isItemSelected(item));
    
    // Build new selection
    let newSelection: any[] = [];
    
    if (this.table.selection && Array.isArray(this.table.selection)) {
      // Keep existing selection from other pages
      newSelection = this.table.selection.filter(item => 
        !currentData.some(pageItem => this.itemsEqual(item, pageItem))
      );
    }

    // Add/remove current page enabled items
    if (!allEnabledSelected) {
      // Add all enabled items from current page
      newSelection = [...newSelection, ...enabledItems];
    }
    // If all were selected, we're deselecting, so don't add them

    // Update selection
    this.table.selection = newSelection;
    
    // Emit change
    if (this.table.selectionChange) {
      this.table.selectionChange.emit(this.table.selection);
    }

    // Update visual state
    this.updateTableCheckboxes();
    
    setTimeout(() => {
      this.updateHeaderCheckbox();
      this.isProcessingToggle = false;
    }, 50);
  }

  private getCurrentPageData(): any[] {
    // For paginated tables
    if (this.table.paginator && this.table.rows) {
      const first = this.table.first || 0;
      const rows = this.table.rows;
      return (this.table.filteredValue || this.table.value || []).slice(first, first + rows);
    }
    
    // For non-paginated tables
    return this.table.filteredValue || this.table.value || [];
  }

  private getEnabledItemsFromData(data: any[]): any[] {
    const enabledItems: any[] = [];
    const checkboxes = this.getBodyCheckboxes();
    
    if (checkboxes.length > 0) {
      // Use actual checkbox state
      data.forEach((item, index) => {
        if (index < checkboxes.length) {
          const checkbox = checkboxes[index];
          if (!checkbox.disabled) {
            enabledItems.push(item);
          }
        }
      });
    } else {
      // If no checkboxes found, assume all are enabled
      return [...data];
    }
    
    return enabledItems;
  }

  private cleanupDisabledFromSelection() {
    if (!this.table.selection || !Array.isArray(this.table.selection)) {
      return;
    }

    const currentData = this.getCurrentPageData();
    const enabledItems = this.getEnabledItemsFromData(currentData);
    
    // Remove disabled items from selection
    const cleanedSelection = this.table.selection.filter(selectedItem => {
      // Check if this item is in current page
      const isInCurrentPage = currentData.some(item => this.itemsEqual(item, selectedItem));
      
      if (isInCurrentPage) {
        // If in current page, only keep if enabled
        return enabledItems.some(item => this.itemsEqual(item, selectedItem));
      }
      
      // Keep items from other pages
      return true;
    });

    if (cleanedSelection.length !== this.table.selection.length) {
      this.table.selection = cleanedSelection;
      if (this.table.selectionChange) {
        this.table.selectionChange.emit(cleanedSelection);
      }
    }
  }

  private updateTableCheckboxes() {
    const checkboxes = this.getBodyCheckboxes();
    const currentData = this.getCurrentPageData();
    
    checkboxes.forEach((checkbox, index) => {
      if (index < currentData.length) {
        const item = currentData[index];
        const isSelected = this.isItemSelected(item);
        
        if (checkbox.disabled) {
          // Force disabled checkboxes to be unchecked
          this.renderer.setProperty(checkbox, 'checked', false);
        } else {
          // Update enabled checkboxes
          this.renderer.setProperty(checkbox, 'checked', isSelected);
        }
        
        // Update visual state through PrimeNG's classes
        const wrapper = checkbox.closest('.p-checkbox');
        if (wrapper) {
          const box = wrapper.querySelector('.p-checkbox-box');
          if (box) {
            if (isSelected && !checkbox.disabled) {
              this.renderer.addClass(box, 'p-highlight');
            } else {
              this.renderer.removeClass(box, 'p-highlight');
            }
          }
        }
      }
    });
  }

  private updateHeaderCheckbox() {
    const headerEl = this.getHeaderCheckboxElement();
    if (!headerEl) return;

    const checkbox = headerEl.querySelector('input[type="checkbox"]') as HTMLInputElement;
    if (!checkbox) return;

    // Force enable
    this.renderer.setProperty(checkbox, 'disabled', false);

    const currentData = this.getCurrentPageData();
    const enabledItems = this.getEnabledItemsFromData(currentData);
    
    let checkedCount = 0;
    let enabledCount = enabledItems.length;

    enabledItems.forEach(item => {
      if (this.isItemSelected(item)) {
        checkedCount++;
      }
    });

    // Update checkbox state
    if (enabledCount === 0 || checkedCount === 0) {
      this.renderer.setProperty(checkbox, 'checked', false);
      this.renderer.setProperty(checkbox, 'indeterminate', false);
    } else if (checkedCount === enabledCount) {
      this.renderer.setProperty(checkbox, 'checked', true);
      this.renderer.setProperty(checkbox, 'indeterminate', false);
    } else {
      this.renderer.setProperty(checkbox, 'checked', false);
      this.renderer.setProperty(checkbox, 'indeterminate', true);
    }

    this.updateHeaderVisualState();
  }

  private updateHeaderVisualState() {
    const headerEl = this.getHeaderCheckboxElement();
    if (!headerEl) return;

    const checkbox = headerEl.querySelector('input[type="checkbox"]') as HTMLInputElement;
    if (!checkbox) return;

    const wrapper = headerEl.querySelector('.p-checkbox');
    if (wrapper) {
      this.renderer.removeClass(wrapper, 'p-checkbox-disabled');
      this.renderer.removeClass(wrapper, 'p-disabled');
      
      const box = wrapper.querySelector('.p-checkbox-box');
      if (box) {
        this.renderer.removeClass(box, 'p-disabled');
        
        // Update highlight based on state
        if (checkbox.checked || checkbox.indeterminate) {
          this.renderer.addClass(box, 'p-highlight');
        } else {
          this.renderer.removeClass(box, 'p-highlight');
        }
        
        // Update icon
        const icon = box.querySelector('.p-checkbox-icon');
        if (icon) {
          // Clear existing classes
          this.renderer.setAttribute(icon, 'class', 'p-checkbox-icon');
          
          if (checkbox.checked) {
            this.renderer.addClass(icon, 'pi');
            this.renderer.addClass(icon, 'pi-check');
          } else if (checkbox.indeterminate) {
            this.renderer.addClass(icon, 'pi');
            this.renderer.addClass(icon, 'pi-minus');
          } else {
            this.renderer.addClass(icon, 'pi');
          }
        }
      }
    }
  }

  private getHeaderCheckboxElement(): HTMLElement | null {
    return this.element.nativeElement.querySelector('thead p-tableheadercheckbox') ||
           this.element.nativeElement.querySelector('thead .p-selection-column');
  }

  private getBodyCheckboxes(): HTMLInputElement[] {
    const checkboxes = this.element.nativeElement.querySelectorAll(
      'tbody .p-selection-column input[type="checkbox"], tbody p-tablecheckbox input[type="checkbox"]'
    );
    return Array.from(checkboxes);
  }

  private isItemSelected(item: any): boolean {
    if (!this.table.selection) return false;
    
    if (Array.isArray(this.table.selection)) {
      return this.table.selection.some(selectedItem => 
        this.itemsEqual(item, selectedItem)
      );
    }
    
    return this.itemsEqual(item, this.table.selection);
  }

  private itemsEqual(item1: any, item2: any): boolean {
    if (item1 === item2) return true;
    if (!item1 || !item2) return false;
    
    if (this.table.dataKey) {
      const key1 = this.resolveFieldData(item1, this.table.dataKey);
      const key2 = this.resolveFieldData(item2, this.table.dataKey);
      if (key1 !== undefined && key2 !== undefined) {
        return key1 === key2;
      }
    }
    
    const idProps = ['id', 'ID', '_id', 'key', 'uuid', 'code'];
    for (const prop of idProps) {
      if (item1[prop] !== undefined && item2[prop] !== undefined) {
        return item1[prop] === item2[prop];
      }
    }
    
    return false;
  }

  private resolveFieldData(data: any, field: string): any {
    if (!data || !field) return undefined;
    
    if (field.indexOf('.') === -1) {
      return data[field];
    }
    
    const fields = field.split('.');
    let value = data;
    for (const f of fields) {
      if (value == null) return undefined;
      value = value[f];
    }
    return value;
  }
}
