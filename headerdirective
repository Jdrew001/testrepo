import { Directive, Host, Input, OnInit, AfterViewInit } from '@angular/core';
import { Table } from 'primeng/table';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, AfterViewInit {

  @Input() previouslySelected: any[] = [];  // Items that were already selected before
  private checkInterval: any;

  constructor(@Host() private table: Table) {}

  ngOnInit() {
    // Override PrimeNG's internal toggle method
    const originalToggleRowsWithCheckbox = (this.table as any).toggleRowsWithCheckbox;
    (this.table as any).toggleRowsWithCheckbox = (event: any, check: boolean) => {
      this.handleToggleAll(event, check);
    };

    // Override the method that checks if all rows are selected
    (this.table as any).allRowsSelected = () => {
      return this.areAllSelectableItemsSelected();
    };

    // Listen to selection changes
    if (this.table.selectionChange) {
      this.table.selectionChange.subscribe(() => {
        this.cleanSelection();
        this.updateHeaderState();
      });
    }
  }

  ngAfterViewInit() {
    setTimeout(() => {
      this.cleanSelection();
      this.updateHeaderState();
    }, 0);

    // Keep header enabled/disabled based on selectable items
    this.checkInterval = setInterval(() => {
      this.updateHeaderState();
    }, 100);
  }

  ngOnDestroy() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
    }
  }

  private handleToggleAll(event: any, check: boolean) {
    // Get ALL data across all pages
    const allData = this.table.filteredValue || this.table.value || [];
    if (!allData.length) return;

    // Get only selectable items (not previously selected)
    const selectableItems = allData.filter(item => this.isSelectable(item));
    
    if (!selectableItems.length) {
      // Nothing to select/deselect
      return;
    }

    if (check) {
      // Select all selectable items
      this.table.selection = [...selectableItems];
    } else {
      // Clear selection
      this.table.selection = [];
    }

    // Update PrimeNG's internal selection keys
    this.updateSelectionKeys();
    
    // Emit events
    this.table.onHeaderCheckboxToggle.emit({
      originalEvent: event,
      checked: check
    });
    
    if (this.table.selectionChange) {
      this.table.selectionChange.emit(this.table.selection);
    }
  }

  private areAllSelectableItemsSelected(): boolean {
    const allData = this.table.filteredValue || this.table.value || [];
    if (!allData.length) return false;
    
    const selectableItems = allData.filter(item => this.isSelectable(item));
    if (!selectableItems.length) return false;
    
    if (!this.table.selection || !Array.isArray(this.table.selection)) {
      return false;
    }
    
    // Check if every selectable item is in the selection
    return selectableItems.every(item =>
      this.table.selection.some(selected => this.equals(item, selected))
    );
  }

  private updateHeaderState() {
    // Access PrimeNG's internal header checkbox reference
    const headerCheckbox = (this.table as any).headerCheckbox;
    if (!headerCheckbox) return;

    const allData = this.table.filteredValue || this.table.value || [];
    const selectableItems = allData.filter(item => this.isSelectable(item));
    const hasSelectableItems = selectableItems.length > 0;
    
    // Disable header checkbox if no selectable items (all items are previously selected)
    if (headerCheckbox.disabled !== !hasSelectableItems) {
      headerCheckbox.disabled = !hasSelectableItems;
      // Also update the native element if it exists
      if (headerCheckbox.el && headerCheckbox.el.nativeElement) {
        headerCheckbox.el.nativeElement.disabled = !hasSelectableItems;
      }
    }

    // Update the checked/indeterminate state only if there are selectable items
    if (hasSelectableItems) {
      const selectedCount = selectableItems.filter(item =>
        this.table.selection?.some(selected => this.equals(item, selected))
      ).length;
      
      if (selectedCount === 0) {
        headerCheckbox.checked = false;
        (this.table as any).headerCheckboxFocus = false;
      } else if (selectedCount === selectableItems.length) {
        headerCheckbox.checked = true;
        (this.table as any).headerCheckboxFocus = true;
      } else {
        // Partial selection - show indeterminate state
        headerCheckbox.checked = false;
        (this.table as any).headerCheckboxFocus = false;
        // Set indeterminate state if supported
        if (headerCheckbox.el && headerCheckbox.el.nativeElement) {
          headerCheckbox.el.nativeElement.indeterminate = true;
        }
      }
    } else {
      // When all items are previously selected, ensure checkbox appears unchecked and disabled
      headerCheckbox.checked = false;
      (this.table as any).headerCheckboxFocus = false;
      if (headerCheckbox.el && headerCheckbox.el.nativeElement) {
        headerCheckbox.el.nativeElement.indeterminate = false;
      }
    }
  }

  private cleanSelection() {
    if (!this.table.selection || !Array.isArray(this.table.selection)) return;
    
    // Remove previously selected items from current selection
    const cleaned = this.table.selection.filter(selected => 
      this.isSelectable(selected)
    );
    
    // Remove duplicates
    const uniqueCleaned: any[] = [];
    const seen = new Set<string>();
    
    cleaned.forEach(item => {
      const key = `${item.entityType}_${item.entityId}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueCleaned.push(item);
      }
    });
    
    if (uniqueCleaned.length !== this.table.selection.length) {
      this.table.selection = uniqueCleaned;
      this.updateSelectionKeys();
    }
  }

  private isSelectable(item: any): boolean {
    if (!this.previouslySelected || this.previouslySelected.length === 0) {
      return true;
    }
    // Item is selectable if NOT in previously selected list
    return !this.previouslySelected.some(selected => this.equals(item, selected));
  }

  private updateSelectionKeys() {
    // Update PrimeNG's internal selection tracking
    const keys: any = {};
    if (Array.isArray(this.table.selection)) {
      this.table.selection.forEach(item => {
        if (item.entityId !== undefined && item.entityType !== undefined) {
          const compositeKey = `${item.entityType}_${item.entityId}`;
          keys[compositeKey] = 1;
        }
      });
    }
    (this.table as any).selectionKeys = keys;
  }

  private equals(a: any, b: any): boolean {
    if (a === b) return true;
    if (!a || !b) return false;
    
    if (a.entityId !== undefined && a.entityType !== undefined &&
        b.entityId !== undefined && b.entityType !== undefined) {
      return a.entityId === b.entityId && a.entityType === b.entityType;
    }
    
    return false;
  }
}