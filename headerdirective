import { Directive, Host, Input, OnInit, AfterViewInit, ElementRef } from '@angular/core';
import { Table } from 'primeng/table';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, AfterViewInit {

  @Input() selectableItems: any[] = [];
  private headerClickListener: any;

  constructor(
    @Host() private table: Table,
    private el: ElementRef
  ) {}

  ngOnInit() {
    // Override the header checkbox state check
    (this.table as any).isAllRowsSelected = () => {
      const data = this.table.filteredValue || this.table.value || [];
      if (!data.length) return false;
      
      const selectableData = data.filter(item => this.isSelectable(item));
      if (!selectableData.length) return false;
      
      if (!this.table.selection || !Array.isArray(this.table.selection)) return false;
      
      return selectableData.every(item => 
        this.table.selection.some(selected => this.equals(item, selected))
      );
    };
  }

  ngAfterViewInit() {
    setTimeout(() => {
      this.setupHeaderCheckbox();
      this.cleanSelection();
    }, 100);

    // Re-setup after pagination
    if (this.table.onPage) {
      this.table.onPage.subscribe(() => {
        setTimeout(() => this.setupHeaderCheckbox(), 100);
      });
    }
  }

  private setupHeaderCheckbox() {
    // Find the header checkbox
    const headerCheckbox = this.el.nativeElement.querySelector('thead input[type="checkbox"]');
    if (!headerCheckbox) {
      setTimeout(() => this.setupHeaderCheckbox(), 50);
      return;
    }

    // Remove old listener if exists
    if (this.headerClickListener) {
      headerCheckbox.removeEventListener('click', this.headerClickListener);
    }

    // Add our own click handler
    this.headerClickListener = (event: Event) => {
      event.stopPropagation();
      event.preventDefault();
      
      this.toggleAll();
    };

    headerCheckbox.addEventListener('click', this.headerClickListener, true);

    // Keep it enabled
    setInterval(() => {
      if (headerCheckbox && this.table.value?.length > 0) {
        const hasSelectableItems = (this.table.value || []).some(item => this.isSelectable(item));
        headerCheckbox.disabled = !hasSelectableItems;
      }
    }, 100);
  }

  private toggleAll() {
    const data = this.table.filteredValue || this.table.value || [];
    if (!data.length) return;

    // Get selectable items
    const selectableData = data.filter(item => this.isSelectable(item));
    if (!selectableData.length) return;

    // IMPORTANT: Filter out already selected items from selectable items
    const currentSelection = this.table.selection || [];
    const selectableNotYetSelected = selectableData.filter(item => 
      !currentSelection.some(selected => this.equals(item, selected))
    );

    // Check if all selectable items are already selected
    const allSelectableAreSelected = selectableData.every(item => 
      currentSelection.some(selected => this.equals(item, selected))
    );

    // Toggle logic
    if (allSelectableAreSelected) {
      // Deselect all selectable items (keep non-selectable selected items)
      this.table.selection = currentSelection.filter(selected => 
        !selectableData.some(selectable => this.equals(selected, selectable))
      );
    } else {
      // Add unselected selectable items to current selection
      this.table.selection = [
        ...currentSelection,
        ...selectableNotYetSelected
      ];
    }

    // Update keys
    this.updateSelectionKeys();

    // Emit change
    if (this.table.selectionChange) {
      this.table.selectionChange.emit(this.table.selection);
    }

    // Update visual state
    this.updateCheckboxes();
  }

  private updateCheckboxes() {
    // Update header checkbox state
    const headerCheckbox = this.el.nativeElement.querySelector('thead input[type="checkbox"]');
    if (headerCheckbox) {
      const data = this.table.filteredValue || this.table.value || [];
      const selectableData = data.filter(item => this.isSelectable(item));
      const selectedCount = this.table.selection?.length || 0;
      
      if (selectedCount === 0) {
        headerCheckbox.checked = false;
        headerCheckbox.indeterminate = false;
      } else if (selectedCount === selectableData.length && selectableData.length > 0) {
        headerCheckbox.checked = true;
        headerCheckbox.indeterminate = false;
      } else {
        headerCheckbox.checked = false;
        headerCheckbox.indeterminate = true;
      }
    }

    // Update body checkboxes
    const bodyCheckboxes = this.el.nativeElement.querySelectorAll('tbody input[type="checkbox"]');
    const currentPageData = this.getCurrentPageData();
    
    bodyCheckboxes.forEach((checkbox: HTMLInputElement, index: number) => {
      if (index < currentPageData.length) {
        const item = currentPageData[index];
        checkbox.checked = this.table.selection?.some(selected => this.equals(item, selected)) || false;
        checkbox.disabled = !this.isSelectable(item);
      }
    });
  }

  private getCurrentPageData(): any[] {
    if (this.table.paginator && this.table.rows) {
      const first = this.table.first || 0;
      return (this.table.filteredValue || this.table.value || []).slice(first, first + this.table.rows);
    }
    return this.table.filteredValue || this.table.value || [];
  }

  private cleanSelection() {
    if (!this.table.selection || !Array.isArray(this.table.selection)) return;
    
    // Remove items that are NOT in selectableItems
    const cleaned = this.table.selection.filter(selected => this.isSelectable(selected));
    
    // Also remove any duplicates (items with same entityId and entityType)
    const uniqueCleaned: any[] = [];
    const seen = new Set<string>();
    
    cleaned.forEach(item => {
      const key = `${item.entityType}_${item.entityId}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueCleaned.push(item);
      }
    });
    
    if (uniqueCleaned.length !== this.table.selection.length) {
      this.table.selection = uniqueCleaned;
      this.updateSelectionKeys();
      if (this.table.selectionChange) {
        this.table.selectionChange.emit(this.table.selection);
      }
    }
  }

  private isSelectable(item: any): boolean {
    if (!this.selectableItems || this.selectableItems.length === 0) {
      return true;
    }
    return this.selectableItems.some(selectable => this.equals(item, selectable));
  }

  private updateSelectionKeys() {
    const keys: any = {};
    if (Array.isArray(this.table.selection)) {
      this.table.selection.forEach(item => {
        if (item.entityId !== undefined && item.entityType !== undefined) {
          const compositeKey = `${item.entityType}_${item.entityId}`;
          keys[compositeKey] = 1;
        }
      });
    }
    (this.table as any).selectionKeys = keys;
  }

  private equals(a: any, b: any): boolean {
    if (a === b) return true;
    if (!a || !b) return false;
    
    if (a.entityId !== undefined && a.entityType !== undefined &&
        b.entityId !== undefined && b.entityType !== undefined) {
      return a.entityId === b.entityId && a.entityType === b.entityType;
    }
    
    return false;
  }
}
