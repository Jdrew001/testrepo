import { Directive, Host, Input, OnInit, AfterViewInit, ElementRef } from '@angular/core';
import { Table } from 'primeng/table';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, AfterViewInit {

  @Input() previouslySelected: any[] = [];  // Items that were already selected before
  private headerClickListener: any;

  constructor(
    @Host() private table: Table,
    private el: ElementRef
  ) {}

  ngOnInit() {
    // Listen to selection changes to update header state
    if (this.table.selectionChange) {
      this.table.selectionChange.subscribe(() => {
        setTimeout(() => this.updateCheckboxes(), 0);
      });
    }
  }.table.filteredValue || this.table.value || [];
      if (!data.length) return false;
      
      const selectableData = data.filter(item => this.isSelectable(item));
      if (!selectableData.length) return false;
      
      if (!this.table.selection || !Array.isArray(this.table.selection)) return false;
      
      return selectableData.every(item => 
        this.table.selection.some(selected => this.equals(item, selected))
      );
    };
  }

  ngAfterViewInit() {
    setTimeout(() => {
      this.setupHeaderCheckbox();
      this.cleanSelection();
    }, 100);

    // Re-setup after pagination
    if (this.table.onPage) {
      this.table.onPage.subscribe(() => {
        setTimeout(() => this.setupHeaderCheckbox(), 100);
      });
    }
  }

  private setupHeaderCheckbox() {
    // Find the header checkbox
    const headerCheckbox = this.el.nativeElement.querySelector('thead input[type="checkbox"]');
    if (!headerCheckbox) {
      setTimeout(() => this.setupHeaderCheckbox(), 50);
      return;
    }

    // Remove old listener if exists
    if (this.headerClickListener) {
      headerCheckbox.removeEventListener('click', this.headerClickListener);
    }

    // Add our own click handler
    this.headerClickListener = (event: Event) => {
      event.stopPropagation();
      event.preventDefault();
      
      this.toggleAll();
    };

    headerCheckbox.addEventListener('click', this.headerClickListener, true);

    // Keep it enabled ONLY if there are selectable items
    setInterval(() => {
      if (headerCheckbox && this.table.value?.length > 0) {
        // Check if ANY item is selectable (not previously selected)
        const hasSelectableItems = (this.table.value || []).some(item => this.isSelectable(item));
        
        // Disable header if ALL items are previously selected
        headerCheckbox.disabled = !hasSelectableItems;
        
        // Update visual state
        const wrapper = headerCheckbox.closest('.p-checkbox');
        if (wrapper) {
          if (!hasSelectableItems) {
            wrapper.classList.add('p-checkbox-disabled', 'p-disabled');
          } else {
            wrapper.classList.remove('p-checkbox-disabled', 'p-disabled');
          }
        }
      }
    }, 100);
  }

  private toggleAll() {
    // Get ALL data (not just current page) - handles 10+ records across pages
    const allData = this.table.filteredValue || this.table.value || [];
    if (!allData.length) return;

    // Get ALL selectable items across ALL pages
    const allSelectableItems = allData.filter(item => this.isSelectable(item));
    if (!allSelectableItems.length) {
      // All items are previously selected, nothing to do
      return;
    }

    // Filter out already selected items from selectable items
    const currentSelection = this.table.selection || [];
    const notYetSelected = allSelectableItems.filter(item => 
      !currentSelection.some(selected => this.equals(item, selected))
    );

    // Check if all selectable items are already selected
    const allSelectableAreSelected = allSelectableItems.every(item => 
      currentSelection.some(selected => this.equals(item, selected))
    );

    // Toggle logic
    if (allSelectableAreSelected) {
      // Deselect all selectable items (preserve previously selected items in selection)
      this.table.selection = currentSelection.filter(selected => 
        !allSelectableItems.some(selectable => this.equals(selected, selectable))
      );
    } else {
      // Add ALL unselected selectable items to current selection (across all pages)
      this.table.selection = [
        ...currentSelection,
        ...notYetSelected
      ];
    }

    // Update keys
    this.updateSelectionKeys();

    // Emit change
    if (this.table.selectionChange) {
      this.table.selectionChange.emit(this.table.selection);
    }

    // Update visual state
    this.updateCheckboxes();
  }

  private updateCheckboxes() {
    // Update header checkbox state
    const headerCheckbox = this.el.nativeElement.querySelector('thead input[type="checkbox"]');
    if (headerCheckbox) {
      // Use ALL data (not just current page)
      const allData = this.table.filteredValue || this.table.value || [];
      const allSelectableItems = allData.filter(item => this.isSelectable(item));
      const selectedCount = this.table.selection?.length || 0;
      
      // Count how many selectable items are selected
      const selectedSelectableCount = allSelectableItems.filter(item =>
        this.table.selection?.some(selected => this.equals(item, selected))
      ).length;
      
      if (allSelectableItems.length === 0) {
        // No selectable items - header should be disabled
        headerCheckbox.checked = false;
        headerCheckbox.indeterminate = false;
        headerCheckbox.disabled = true;
      } else if (selectedSelectableCount === 0) {
        // No selection
        headerCheckbox.checked = false;
        headerCheckbox.indeterminate = false;
        headerCheckbox.disabled = false;
      } else if (selectedSelectableCount === allSelectableItems.length) {
        // All selectable items are selected
        headerCheckbox.checked = true;
        headerCheckbox.indeterminate = false;
        headerCheckbox.disabled = false;
      } else {
        // Partial selection
        headerCheckbox.checked = false;
        headerCheckbox.indeterminate = true;
        headerCheckbox.disabled = false;
      }
    }

    // Update body checkboxes for current page only
    const bodyCheckboxes = this.el.nativeElement.querySelectorAll('tbody input[type="checkbox"]');
    const currentPageData = this.getCurrentPageData();
    
    bodyCheckboxes.forEach((checkbox: HTMLInputElement, index: number) => {
      if (index < currentPageData.length) {
        const item = currentPageData[index];
        checkbox.checked = this.table.selection?.some(selected => this.equals(item, selected)) || false;
        // Disable if item is previously selected
        checkbox.disabled = !this.isSelectable(item);
      }
    });
  }

  private getCurrentPageData(): any[] {
    if (this.table.paginator && this.table.rows) {
      const first = this.table.first || 0;
      return (this.table.filteredValue || this.table.value || []).slice(first, first + this.table.rows);
    }
    return this.table.filteredValue || this.table.value || [];
  }

  private cleanSelection() {
    if (!this.table.selection || !Array.isArray(this.table.selection)) return;
    
    // Remove items that are NOT in selectableItems
    const cleaned = this.table.selection.filter(selected => this.isSelectable(selected));
    
    // Also remove any duplicates (items with same entityId and entityType)
    const uniqueCleaned: any[] = [];
    const seen = new Set<string>();
    
    cleaned.forEach(item => {
      const key = `${item.entityType}_${item.entityId}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueCleaned.push(item);
      }
    });
    
    if (uniqueCleaned.length !== this.table.selection.length) {
      this.table.selection = uniqueCleaned;
      this.updateSelectionKeys();
      if (this.table.selectionChange) {
        this.table.selectionChange.emit(this.table.selection);
      }
    }
  }

  private isSelectable(item: any): boolean {
    // If no previously selected list provided, everything is selectable
    if (!this.previouslySelected || this.previouslySelected.length === 0) {
      return true;
    }
    // Item is selectable if it's NOT in the previously selected list
    return !this.previouslySelected.some(selected => this.equals(item, selected));
  }

  private updateSelectionKeys() {
    const keys: any = {};
    if (Array.isArray(this.table.selection)) {
      this.table.selection.forEach(item => {
        if (item.entityId !== undefined && item.entityType !== undefined) {
          const compositeKey = `${item.entityType}_${item.entityId}`;
          keys[compositeKey] = 1;
        }
      });
    }
    (this.table as any).selectionKeys = keys;
  }

  private equals(a: any, b: any): boolean {
    if (a === b) return true;
    if (!a || !b) return false;
    
    if (a.entityId !== undefined && a.entityType !== undefined &&
        b.entityId !== undefined && b.entityType !== undefined) {
      return a.entityId === b.entityId && a.entityType === b.entityType;
    }
    
    return false;
  }
}
