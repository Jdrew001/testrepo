import { Directive, Host, OnInit, OnDestroy, AfterViewInit, ElementRef } from '@angular/core';
import { Table } from 'primeng/table';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, OnDestroy, AfterViewInit {
  
  private originalMethod: any;
  private cleanupTimer: any;

  constructor(
    @Host() private table: Table,
    private element: ElementRef
  ) {}

  ngOnInit() {
    // Override the "select all" method
    this.originalMethod = this.table.toggleRowsWithCheckbox?.bind(this.table);
    
    if (this.table.toggleRowsWithCheckbox) {
      this.table.toggleRowsWithCheckbox = (event: Event, checked: boolean) => {
        if (checked) {
          // When selecting all, only select enabled rows
          this.selectOnlyEnabledRows(event);
        } else {
          // When deselecting, use original method
          this.originalMethod(event, checked);
        }
      };
    }
  }

  ngAfterViewInit() {
    // Clean up any initially selected disabled items
    setTimeout(() => this.cleanupSelection(), 100);
  }

  ngOnDestroy() {
    // Restore original method
    if (this.originalMethod) {
      this.table.toggleRowsWithCheckbox = this.originalMethod;
    }
    
    if (this.cleanupTimer) {
      clearTimeout(this.cleanupTimer);
    }
  }

  private selectOnlyEnabledRows(event: Event) {
    if (!this.table.value) return;

    // Find all enabled checkboxes
    const checkboxes = this.element.nativeElement.querySelectorAll(
      'tbody input[type="checkbox"]'
    );

    const enabledItems: any[] = [];
    
    checkboxes.forEach((checkbox: HTMLInputElement, index: number) => {
      if (!checkbox.disabled && this.table.value[index]) {
        enabledItems.push(this.table.value[index]);
      }
    });

    // Update selection
    this.table.selection = enabledItems;
    this.table.selectionChange.emit(this.table.selection);
    
    // Emit header checkbox event
    this.table.onHeaderCheckboxToggle.emit({
      originalEvent: event,
      checked: true
    });

    // Update PrimeNG internal state
    if (this.table.updateSelectionKeys) {
      this.table.updateSelectionKeys();
    }

    // Force header checkbox to be checked
    setTimeout(() => {
      this.updateHeaderCheckboxState(true);
    }, 0);
  }

  private cleanupSelection() {
    if (!this.table.selection?.length) return;

    // Get current enabled items
    const checkboxes = this.element.nativeElement.querySelectorAll(
      'tbody input[type="checkbox"]'
    );

    const enabledItems = new Set();
    checkboxes.forEach((checkbox: HTMLInputElement, index: number) => {
      if (!checkbox.disabled && this.table.value?.[index]) {
        enabledItems.add(this.table.value[index]);
      }
    });

    // Filter out any disabled items from selection
    const validSelection = this.table.selection.filter(item => enabledItems.has(item));
    
    if (validSelection.length !== this.table.selection.length) {
      this.table.selection = validSelection;
      this.table.selectionChange.emit(this.table.selection);
      
      // Update header checkbox state after cleanup
      setTimeout(() => {
        this.updateHeaderCheckboxState();
      }, 0);
    }
  }

  private updateHeaderCheckboxState(forceChecked?: boolean) {
    // Find header checkbox
    const headerCheckbox = this.element.nativeElement.querySelector(
      'thead input[type="checkbox"], thead .p-checkbox-box'
    );

    if (headerCheckbox) {
      const totalEnabled = this.getTotalEnabledItems();
      const selectedCount = this.table.selection?.length || 0;
      
      if (forceChecked === true) {
        // Force checked state
        headerCheckbox.checked = true;
        if (headerCheckbox.indeterminate !== undefined) {
          headerCheckbox.indeterminate = false;
        }
      } else {
        // Set proper state based on selection
        const allSelected = selectedCount > 0 && selectedCount === totalEnabled;
        const someSelected = selectedCount > 0 && selectedCount < totalEnabled;
        
        headerCheckbox.checked = allSelected;
        if (headerCheckbox.indeterminate !== undefined) {
          headerCheckbox.indeterminate = someSelected;
        }
      }
    }
  }

  private getTotalEnabledItems(): number {
    const checkboxes = this.element.nativeElement.querySelectorAll(
      'tbody input[type="checkbox"]'
    );
    
    let count = 0;
    checkboxes.forEach((checkbox: HTMLInputElement) => {
      if (!checkbox.disabled) count++;
    });
    
    return count;
  }
}