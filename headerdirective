import { Directive, Host, Input, OnInit, AfterViewInit, ChangeDetectorRef, Optional } from '@angular/core';
import { Table } from 'primeng/table';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, AfterViewInit {

  @Input() previouslySelected: any[] = [];  // Items that were already selected before
  private checkInterval: any;

  constructor(@Host() private table: Table, @Optional() private cdr: ChangeDetectorRef) {}

  ngOnInit() {
    // Override PrimeNG's internal toggle method
    const originalToggleRowsWithCheckbox = (this.table as any).toggleRowsWithCheckbox;
    (this.table as any).toggleRowsWithCheckbox = (event: any, check: boolean) => {
      this.handleToggleAll(event, check);
    };

    // Override the method that checks if all rows are selected
    (this.table as any).allRowsSelected = () => {
      return this.areAllSelectableItemsSelected();
    };

    // Listen to selection changes
    if (this.table.selectionChange) {
      this.table.selectionChange.subscribe(() => {
        this.cleanSelection();
        this.updateHeaderState();
      });
    }
  }

  ngAfterViewInit() {
    setTimeout(() => {
      this.cleanSelection();
      this.updateHeaderState();
      this.attachHeaderCheckboxListener();
    }, 0);

    // Keep header enabled/disabled based on selectable items
    this.checkInterval = setInterval(() => {
      this.updateHeaderState();
    }, 100);
  }

  private attachHeaderCheckboxListener() {
    // Add click listener to header checkbox to ensure proper state
    const headerCheckboxElement = this.table.el.nativeElement.querySelector('.p-datatable-thead .p-checkbox');
    if (headerCheckboxElement) {
      headerCheckboxElement.addEventListener('click', (event: Event) => {
        // Let the directive handle the logic
        setTimeout(() => {
          this.updateHeaderState();
        }, 10);
      });
    }
  }

  ngOnDestroy() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
    }
  }

  private handleToggleAll(event: any, check: boolean) {
    // Get ALL data across all pages
    const allData = this.table.filteredValue || this.table.value || [];
    if (!allData.length) return;

    // Get only selectable items (not previously selected)
    const selectableItems = allData.filter(item => this.isSelectable(item));
    
    if (!selectableItems.length) {
      // Nothing to select/deselect
      return;
    }

    if (check) {
      // Select all selectable items
      this.table.selection = [...selectableItems];
    } else {
      // Clear selection
      this.table.selection = [];
    }

    // Update PrimeNG's internal selection keys
    this.updateSelectionKeys();
    
    // Emit events
    this.table.onHeaderCheckboxToggle.emit({
      originalEvent: event,
      checked: check
    });
    
    if (this.table.selectionChange) {
      this.table.selectionChange.emit(this.table.selection);
    }
  }

  private areAllSelectableItemsSelected(): boolean {
    const allData = this.table.filteredValue || this.table.value || [];
    if (!allData.length) return false;
    
    const selectableItems = allData.filter(item => this.isSelectable(item));
    if (!selectableItems.length) return false;
    
    if (!this.table.selection || !Array.isArray(this.table.selection)) {
      return false;
    }
    
    // Check if every selectable item is in the selection
    return selectableItems.every(item =>
      this.table.selection.some(selected => this.equals(item, selected))
    );
  }

  private updateHeaderState() {
    // Access PrimeNG's internal header checkbox reference
    const headerCheckbox = (this.table as any).headerCheckbox;
    if (!headerCheckbox) return;

    const allData = this.table.filteredValue || this.table.value || [];
    const selectableItems = allData.filter(item => this.isSelectable(item));
    const hasSelectableItems = selectableItems.length > 0;
    
    // Disable header checkbox if no selectable items (all items are previously selected)
    headerCheckbox.disabled = !hasSelectableItems;
    
    // Update the native checkbox element to be visually disabled
    setTimeout(() => {
      const checkboxElement = this.table.el.nativeElement.querySelector('.p-datatable-thead .p-checkbox-box');
      const inputElement = this.table.el.nativeElement.querySelector('.p-datatable-thead .p-checkbox input');
      
      if (!hasSelectableItems) {
        // Apply disabled styling and attributes
        if (checkboxElement) {
          checkboxElement.classList.add('p-disabled');
          checkboxElement.style.opacity = '0.6';
          checkboxElement.style.cursor = 'not-allowed';
        }
        if (inputElement) {
          inputElement.disabled = true;
          inputElement.setAttribute('disabled', 'disabled');
        }
      } else {
        // Remove disabled styling and attributes
        if (checkboxElement) {
          checkboxElement.classList.remove('p-disabled');
          checkboxElement.style.opacity = '';
          checkboxElement.style.cursor = '';
        }
        if (inputElement) {
          inputElement.disabled = false;
          inputElement.removeAttribute('disabled');
        }
      }
    }, 0);

    // Update the checked/indeterminate state only if there are selectable items
    if (hasSelectableItems) {
      const selectedCount = selectableItems.filter(item =>
        this.table.selection?.some(selected => this.equals(item, selected))
      ).length;
      
      if (selectedCount === 0) {
        headerCheckbox.checked = false;
        (this.table as any).headerCheckboxFocus = false;
        // Update visual state
        setTimeout(() => {
          const checkboxBox = this.table.el.nativeElement.querySelector('.p-datatable-thead .p-checkbox-box');
          const inputElement = this.table.el.nativeElement.querySelector('.p-datatable-thead .p-checkbox input');
          if (checkboxBox) {
            checkboxBox.classList.remove('p-highlight');
          }
          if (inputElement) {
            inputElement.checked = false;
            inputElement.indeterminate = false;
          }
        }, 0);
      } else if (selectedCount === selectableItems.length) {
        headerCheckbox.checked = true;
        (this.table as any).headerCheckboxFocus = true;
        // Update visual state to show as checked
        setTimeout(() => {
          const checkboxBox = this.table.el.nativeElement.querySelector('.p-datatable-thead .p-checkbox-box');
          const inputElement = this.table.el.nativeElement.querySelector('.p-datatable-thead .p-checkbox input');
          const iconElement = this.table.el.nativeElement.querySelector('.p-datatable-thead .p-checkbox-icon');
          if (checkboxBox) {
            checkboxBox.classList.add('p-highlight');
          }
          if (inputElement) {
            inputElement.checked = true;
            inputElement.indeterminate = false;
          }
          if (iconElement) {
            iconElement.classList.remove('pi-minus');
            iconElement.classList.add('pi-check');
          }
        }, 0);
        // Trigger change detection to update the view
        if (this.cdr) {
          this.cdr.detectChanges();
        }
      } else {
        // Partial selection - show indeterminate state
        headerCheckbox.checked = false;
        (this.table as any).headerCheckboxFocus = false;
        // Set indeterminate state if supported
        setTimeout(() => {
          const checkboxBox = this.table.el.nativeElement.querySelector('.p-datatable-thead .p-checkbox-box');
          const inputElement = this.table.el.nativeElement.querySelector('.p-datatable-thead .p-checkbox input');
          const iconElement = this.table.el.nativeElement.querySelector('.p-datatable-thead .p-checkbox-icon');
          if (checkboxBox) {
            checkboxBox.classList.add('p-highlight');
          }
          if (inputElement) {
            inputElement.checked = false;
            inputElement.indeterminate = true;
          }
          if (iconElement) {
            iconElement.classList.remove('pi-check');
            iconElement.classList.add('pi-minus');
          }
        }, 0);
      }
    } else {
      // When all items are previously selected, ensure checkbox appears unchecked and disabled
      headerCheckbox.checked = false;
      (this.table as any).headerCheckboxFocus = false;
    }
  }

  private cleanSelection() {
    if (!this.table.selection || !Array.isArray(this.table.selection)) return;
    
    // Remove previously selected items from current selection
    const cleaned = this.table.selection.filter(selected => 
      this.isSelectable(selected)
    );
    
    // Remove duplicates
    const uniqueCleaned: any[] = [];
    const seen = new Set<string>();
    
    cleaned.forEach(item => {
      const key = `${item.entityType}_${item.entityId}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueCleaned.push(item);
      }
    });
    
    if (uniqueCleaned.length !== this.table.selection.length) {
      this.table.selection = uniqueCleaned;
      this.updateSelectionKeys();
    }
  }

  private isSelectable(item: any): boolean {
    if (!this.previouslySelected || this.previouslySelected.length === 0) {
      return true;
    }
    // Item is selectable if NOT in previously selected list
    return !this.previouslySelected.some(selected => this.equals(item, selected));
  }

  private updateSelectionKeys() {
    // Update PrimeNG's internal selection tracking
    const keys: any = {};
    if (Array.isArray(this.table.selection)) {
      this.table.selection.forEach(item => {
        if (item.entityId !== undefined && item.entityType !== undefined) {
          const compositeKey = `${item.entityType}_${item.entityId}`;
          keys[compositeKey] = 1;
        }
      });
    }
    (this.table as any).selectionKeys = keys;
  }

  private equals(a: any, b: any): boolean {
    if (a === b) return true;
    if (!a || !b) return false;
    
    if (a.entityId !== undefined && a.entityType !== undefined &&
        b.entityId !== undefined && b.entityType !== undefined) {
      return a.entityId === b.entityId && a.entityType === b.entityType;
    }
    
    return false;
  }
}