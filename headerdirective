import { Directive, Host, OnInit, OnDestroy, AfterViewInit, ElementRef, Renderer2 } from '@angular/core';
import { Table } from 'primeng/table';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, OnDestroy, AfterViewInit {
  
  private destroy$ = new Subject<void>();
  private headerCheckboxClickListener?: (event: Event) => void;
  private headerCheckboxChangeListener?: (event: Event) => void;

  constructor(
    @Host() private table: Table,
    private element: ElementRef,
    private renderer: Renderer2
  ) {}

  ngOnInit() {
    // Monitor selection changes to clean up disabled items
    if (this.table.selectionChange) {
      this.table.selectionChange
        .pipe(takeUntil(this.destroy$))
        .subscribe(() => {
          setTimeout(() => {
            this.cleanupDisabledItems();
            this.updateHeaderCheckboxState();
          }, 0);
        });
    }

    // Override updateHeaderCheckboxState if it exists
    this.overrideHeaderCheckboxBehavior();
  }

  ngAfterViewInit() {
    // Setup header checkbox override and initial state
    setTimeout(() => {
      this.interceptHeaderCheckbox();
      this.updateHeaderCheckboxState();
      // Ensure disabled checkboxes are never checked
      this.uncheckDisabledCheckboxes();
    }, 100);

    // Handle table updates, pagination, sorting
    if (this.table.onPage) {
      this.table.onPage
        .pipe(takeUntil(this.destroy$))
        .subscribe(() => {
          setTimeout(() => {
            this.interceptHeaderCheckbox();
            this.updateHeaderCheckboxState();
            this.uncheckDisabledCheckboxes();
          }, 100);
        });
    }

    if (this.table.onSort) {
      this.table.onSort
        .pipe(takeUntil(this.destroy$))
        .subscribe(() => {
          setTimeout(() => {
            this.interceptHeaderCheckbox();
            this.updateHeaderCheckboxState();
            this.uncheckDisabledCheckboxes();
          }, 100);
        });
    }

    // Also listen for filter changes if filtering is used
    if (this.table.onFilter) {
      this.table.onFilter
        .pipe(takeUntil(this.destroy$))
        .subscribe(() => {
          setTimeout(() => {
            this.interceptHeaderCheckbox();
            this.updateHeaderCheckboxState();
            this.uncheckDisabledCheckboxes();
          }, 100);
        });
    }
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    
    // Clean up listeners
    this.removeHeaderCheckboxListeners();
  }

  private overrideHeaderCheckboxBehavior() {
    // Try to override the onHeaderCheckboxToggle handler
    const originalEmit = this.table.onHeaderCheckboxToggle?.emit;
    if (originalEmit) {
      this.table.onHeaderCheckboxToggle.emit = (event: any) => {
        // Prevent the default PrimeNG selection behavior
        event.preventDefault?.();
        event.stopPropagation?.();
        
        // Handle our custom selection logic
        this.handleSelectAll(event);
        // Don't call the original emit as we're handling it ourselves
      };
    }

    // Also try to override the table's internal selection methods if they exist
    const originalUpdateSelection = (this.table as any).updateSelection;
    if (originalUpdateSelection) {
      (this.table as any).updateSelection = (event: any, data: any) => {
        // Only call original for individual row selections, not header checkbox
        if (!event?.target?.closest('thead')) {
          originalUpdateSelection.call(this.table, event, data);
        }
      };
    }
  }

  private interceptHeaderCheckbox() {
    // Remove any existing listeners first
    this.removeHeaderCheckboxListeners();

    const headerCheckbox = this.getHeaderCheckbox();
    if (!headerCheckbox) {
      // Try again with a slight delay as the checkbox might not be rendered yet
      setTimeout(() => {
        const checkbox = this.getHeaderCheckbox();
        if (checkbox) {
          this.attachHeaderCheckboxListeners(checkbox);
        }
      }, 50);
      return;
    }

    this.attachHeaderCheckboxListeners(headerCheckbox);
  }

  private attachHeaderCheckboxListeners(headerCheckbox: HTMLInputElement) {
    // Prevent default behavior and handle our own
    this.headerCheckboxClickListener = (event: Event) => {
      event.stopPropagation();
      event.preventDefault();
      
      // Toggle the checkbox state manually
      const willBeChecked = !headerCheckbox.checked;
      headerCheckbox.checked = willBeChecked;
      
      // Handle the action immediately without setTimeout
      this.handleHeaderCheckboxAction(headerCheckbox);
    };

    this.headerCheckboxChangeListener = (event: Event) => {
      event.stopPropagation();
      event.preventDefault();
    };

    // Use capture phase to intercept before PrimeNG
    headerCheckbox.addEventListener('click', this.headerCheckboxClickListener, true);
    headerCheckbox.addEventListener('change', this.headerCheckboxChangeListener, true);
  }

  private removeHeaderCheckboxListeners() {
    const headerCheckbox = this.getHeaderCheckbox();
    if (headerCheckbox) {
      if (this.headerCheckboxClickListener) {
        headerCheckbox.removeEventListener('click', this.headerCheckboxClickListener as EventListener, true);
      }
      if (this.headerCheckboxChangeListener) {
        headerCheckbox.removeEventListener('change', this.headerCheckboxChangeListener as EventListener, true);
      }
    }
  }

  private handleHeaderCheckboxAction(checkbox: HTMLInputElement) {
    // Determine if we're selecting or deselecting
    const isSelecting = checkbox.checked;

    if (isSelecting) {
      this.selectAllEnabled();
    } else {
      this.deselectAll();
    }

    // Update the header state immediately
    this.updateHeaderCheckboxState();
  }

  private handleSelectAll(event: any) {
    const checked = event?.checked ?? event?.originalEvent?.target?.checked;
    
    if (checked) {
      this.selectAllEnabled();
    } else {
      this.deselectAll();
    }

    setTimeout(() => {
      this.updateHeaderCheckboxState();
      this.uncheckDisabledCheckboxes();
    }, 0);
  }

  private selectAllEnabled() {
    const enabledItems = this.getEnabledItems();
    
    // Update selection with only enabled items
    this.table.selection = [...enabledItems];
    
    // Emit the change
    if (this.table.selectionChange) {
      this.table.selectionChange.emit(this.table.selection);
    }

    // Update the visual state of checkboxes immediately
    this.updateBodyCheckboxes();
  }

  private deselectAll() {
    // Clear selection
    this.table.selection = [];
    
    // Emit the change
    if (this.table.selectionChange) {
      this.table.selectionChange.emit(this.table.selection);
    }

    // Update the visual state of checkboxes immediately
    this.updateBodyCheckboxes();
  }

  private getEnabledItems(): any[] {
    if (!this.table.value) return [];

    const enabledItems: any[] = [];
    const bodyCheckboxes = this.getBodyCheckboxes();

    // If we have checkboxes in the DOM, use them to determine what's enabled
    if (bodyCheckboxes.length > 0) {
      this.table.value.forEach((item, index) => {
        const checkbox = bodyCheckboxes[index];
        // Only add items that have enabled checkboxes
        if (checkbox && !checkbox.disabled) {
          enabledItems.push(item);
        }
      });
    } else {
      // If no checkboxes found (might be virtual scrolling or not rendered yet),
      // we'll need to check the actual data
      // In this case, we can't determine disabled state, so include all
      return [...this.table.value];
    }

    return enabledItems;
  }

  private isRowSelectable(item: any, index: number): boolean {
    // Check if there's a rowSelectable property (it's an @Input on p-table)
    // This would be a function that returns boolean
    if (this.table.rowSelectable && typeof this.table.rowSelectable === 'function') {
      return this.table.rowSelectable({ data: item, index: index });
    }
    
    // Default to true - the row is selectable unless there's a disabled checkbox
    return true;
  }

  private updateBodyCheckboxes() {
    const bodyCheckboxes = this.getBodyCheckboxes();
    
    bodyCheckboxes.forEach((checkbox, index) => {
      const item = this.table.value?.[index];
      if (!item) return;
      
      if (checkbox.disabled) {
        // Always uncheck disabled checkboxes
        checkbox.checked = false;
      } else {
        // Check if item is in selection
        checkbox.checked = this.isItemSelected(item);
      }
    });
  }

  private uncheckDisabledCheckboxes() {
    const bodyCheckboxes = this.getBodyCheckboxes();
    bodyCheckboxes.forEach(checkbox => {
      if (checkbox.disabled) {
        checkbox.checked = false;
        // Also update the visual state of the parent p-checkbox if it exists
        const pCheckbox = checkbox.closest('.p-checkbox');
        if (pCheckbox) {
          const box = pCheckbox.querySelector('.p-checkbox-box');
          if (box) {
            box.classList.remove('p-highlight');
            const icon = box.querySelector('.p-checkbox-icon');
            if (icon) {
              icon.classList.remove('pi', 'pi-check', 'pi-minus');
            }
          }
        }
      }
    });
  }

  private cleanupDisabledItems() {
    if (!this.table.selection?.length) return;

    const enabledItems = this.getEnabledItems();

    // Filter selection to only include enabled items
    const validSelection = this.table.selection.filter(item => 
      enabledItems.some(enabledItem => this.itemsEqual(item, enabledItem))
    );

    if (validSelection.length !== this.table.selection.length) {
      this.table.selection = validSelection;
      if (this.table.selectionChange) {
        this.table.selectionChange.emit(validSelection);
      }
    }

    // Ensure disabled checkboxes are unchecked
    this.uncheckDisabledCheckboxes();
  }

  private updateHeaderCheckboxState() {
    const headerCheckbox = this.getHeaderCheckbox();
    if (!headerCheckbox) return;

    const bodyCheckboxes = this.getBodyCheckboxes();
    let enabledCount = 0;
    let selectedEnabledCount = 0;

    // Count enabled and selected items
    bodyCheckboxes.forEach((checkbox, index) => {
      if (!checkbox.disabled) {
        enabledCount++;
        const item = this.table.value?.[index];
        if (item && this.isItemSelected(item)) {
          selectedEnabledCount++;
        }
      }
    });

    // Update header checkbox state
    if (enabledCount === 0) {
      // No enabled checkboxes - keep header enabled but unchecked
      headerCheckbox.checked = false;
      headerCheckbox.indeterminate = false;
      headerCheckbox.disabled = false; // Keep it enabled
    } else if (selectedEnabledCount === enabledCount && selectedEnabledCount > 0) {
      // All enabled items are selected
      headerCheckbox.checked = true;
      headerCheckbox.indeterminate = false;
      headerCheckbox.disabled = false; // Keep it enabled
    } else if (selectedEnabledCount > 0) {
      // Some enabled items are selected
      headerCheckbox.checked = false;
      headerCheckbox.indeterminate = true;
      headerCheckbox.disabled = false; // Keep it enabled
    } else {
      // No items are selected
      headerCheckbox.checked = false;
      headerCheckbox.indeterminate = false;
      headerCheckbox.disabled = false; // Keep it enabled
    }

    // Also update the visual state of p-checkbox component if it exists
    const pCheckbox = headerCheckbox.closest('.p-checkbox');
    if (pCheckbox) {
      const box = pCheckbox.querySelector('.p-checkbox-box');
      if (box) {
        // Ensure the checkbox box is not disabled
        box.classList.remove('p-disabled');
        
        if (headerCheckbox.checked) {
          box.classList.add('p-highlight');
          const icon = box.querySelector('.p-checkbox-icon');
          if (icon) {
            icon.classList.add('pi', 'pi-check');
            icon.classList.remove('pi-minus');
          }
        } else if (headerCheckbox.indeterminate) {
          box.classList.add('p-highlight');
          const icon = box.querySelector('.p-checkbox-icon');
          if (icon) {
            icon.classList.remove('pi-check');
            icon.classList.add('pi', 'pi-minus');
          }
        } else {
          box.classList.remove('p-highlight');
          const icon = box.querySelector('.p-checkbox-icon');
          if (icon) {
            // Keep the pi class but remove specific icon classes
            icon.classList.add('pi');
            icon.classList.remove('pi-check', 'pi-minus');
          }
        }
      }
    }
  }

  private isItemSelected(item: any): boolean {
    if (!this.table.selection) {
      return false;
    }
    
    // Handle both array and single selection modes
    if (Array.isArray(this.table.selection)) {
      return this.table.selection.some(selectedItem => 
        this.itemsEqual(item, selectedItem)
      );
    } else {
      return this.itemsEqual(item, this.table.selection);
    }
  }

  private getHeaderCheckbox(): HTMLInputElement | null {
    const selectors = [
      'thead p-tableheadercheckbox .p-checkbox-box input[type="checkbox"]',
      'thead .p-selection-column .p-checkbox-box input[type="checkbox"]',
      'thead .p-checkbox input[type="checkbox"]',
      'thead input[type="checkbox"][role="checkbox"]',
      'thead input[type="checkbox"]'
    ];

    for (const selector of selectors) {
      const element = this.element.nativeElement.querySelector(selector);
      if (element) return element as HTMLInputElement;
    }

    return null;
  }

  private getBodyCheckboxes(): HTMLInputElement[] {
    const selectors = [
      'tbody p-tablecheckbox .p-checkbox-box input[type="checkbox"]',
      'tbody .p-selection-column .p-checkbox-box input[type="checkbox"]',
      'tbody .p-checkbox input[type="checkbox"]',
      'tbody input[type="checkbox"][role="checkbox"]',
      'tbody input[type="checkbox"]'
    ];

    for (const selector of selectors) {
      const elements = this.element.nativeElement.querySelectorAll(selector);
      if (elements.length > 0) {
        return Array.from(elements) as HTMLInputElement[];
      }
    }

    return [];
  }

  private itemsEqual(item1: any, item2: any): boolean {
    if (item1 === item2) return true;
    
    // Handle null/undefined
    if (!item1 || !item2) return false;
    
    // If using dataKey on the table, use that
    if (this.table.dataKey) {
      const key1 = this.resolveFieldData(item1, this.table.dataKey);
      const key2 = this.resolveFieldData(item2, this.table.dataKey);
      if (key1 !== undefined && key2 !== undefined) {
        return key1 === key2;
      }
    }
    
    // Try to compare by common ID properties
    const idProps = ['id', 'ID', '_id', 'key', 'uuid', 'code'];
    for (const prop of idProps) {
      if (item1[prop] !== undefined && item2[prop] !== undefined) {
        return item1[prop] === item2[prop];
      }
    }
    
    // Fallback to reference equality
    return false;
  }

  private resolveFieldData(data: any, field: string): any {
    if (!data || !field) return undefined;
    
    if (field.indexOf('.') === -1) {
      return data[field];
    } else {
      const fields = field.split('.');
      let value = data;
      for (const f of fields) {
        if (value == null) {
          return undefined;
        }
        value = value[f];
      }
      return value;
    }
  }
}
