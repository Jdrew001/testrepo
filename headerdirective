import { Directive, Host, Input, OnInit, AfterViewInit, ChangeDetectorRef, Optional } from '@angular/core';
import { Table } from 'primeng/table';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, AfterViewInit {

  @Input() previouslySelected: any[] = [];  // Items that were already selected before
  @Input() headerCheckbox: any;  // Reference to the header checkbox component
  private checkInterval: any;

  constructor(@Host() private table: Table, @Optional() private cdr: ChangeDetectorRef) {}

  ngOnInit() {
    // Override PrimeNG's internal toggle method
    const originalToggleRowsWithCheckbox = (this.table as any).toggleRowsWithCheckbox;
    (this.table as any).toggleRowsWithCheckbox = (event: any, check: boolean) => {
      this.handleToggleAll(event, check);
    };

    // Override the method that checks if all rows are selected
    (this.table as any).allRowsSelected = () => {
      return this.areAllSelectableItemsSelected();
    };
    
    // Override updateHeaderCheckboxState to properly sync state
    (this.table as any).updateHeaderCheckboxState = () => {
      const allSelected = this.areAllSelectableItemsSelected();
      
      // Update the header checkbox using our input reference
      if (this.headerCheckbox) {
        this.headerCheckbox.checked = allSelected;
        // Use PrimeNG checkbox's writeValue to properly update
        if (this.headerCheckbox.writeValue) {
          this.headerCheckbox.writeValue(allSelected);
        }
        // Emit change event
        if (this.headerCheckbox.onChange) {
          this.headerCheckbox.onChange.emit(allSelected);
        }
        // Update the model
        if (this.headerCheckbox.model !== allSelected) {
          this.headerCheckbox.model = allSelected;
        }
        // Trigger change detection
        if (this.headerCheckbox.cd) {
          this.headerCheckbox.cd.markForCheck();
        }
      }
      
      // Then run our custom update
      this.updateHeaderState();
    };

    // Listen to selection changes
    if (this.table.selectionChange) {
      this.table.selectionChange.subscribe(() => {
        this.cleanSelection();
        setTimeout(() => {
          (this.table as any).updateHeaderCheckboxState();
        }, 0);
      });
    }
  }

  ngAfterViewInit() {
    setTimeout(() => {
      this.cleanSelection();
      this.updateHeaderState();
    }, 0);

    // Keep header enabled/disabled based on selectable items
    this.checkInterval = setInterval(() => {
      this.updateHeaderState();
    }, 100);
  }

  ngOnDestroy() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
    }
  }

  private handleToggleAll(event: any, check: boolean) {
    // Get ALL data across all pages
    const allData = this.table.filteredValue || this.table.value || [];
    if (!allData.length) return;

    // Get only selectable items (not previously selected)
    const selectableItems = allData.filter(item => this.isSelectable(item));
    
    if (!selectableItems.length) {
      // Nothing to select/deselect
      return;
    }

    if (check) {
      // Select all selectable items
      this.table.selection = [...selectableItems];
    } else {
      // Clear selection
      this.table.selection = [];
    }

    // Update PrimeNG's internal selection keys
    this.updateSelectionKeys();
    
    // Emit events
    this.table.onHeaderCheckboxToggle.emit({
      originalEvent: event,
      checked: check
    });
    
    if (this.table.selectionChange) {
      this.table.selectionChange.emit(this.table.selection);
    }
    
    // Force update header checkbox state after toggle
    setTimeout(() => {
      this.updateHeaderState();
    }, 0);
  }

  private areAllSelectableItemsSelected(): boolean {
    const allData = this.table.filteredValue || this.table.value || [];
    if (!allData.length) return false;
    
    const selectableItems = allData.filter(item => this.isSelectable(item));
    if (!selectableItems.length) return false;
    
    if (!this.table.selection || !Array.isArray(this.table.selection)) {
      return false;
    }
    
    // Check if every selectable item is in the selection
    return selectableItems.every(item =>
      this.table.selection.some(selected => this.equals(item, selected))
    );
  }

  private updateHeaderState() {
    const allData = this.table.filteredValue || this.table.value || [];
    const selectableItems = allData.filter(item => this.isSelectable(item));
    const hasSelectableItems = selectableItems.length > 0;
    
    if (!hasSelectableItems) {
      // Disable when no selectable items (all are previously selected)
      if (this.headerCheckbox) {
        this.headerCheckbox.disabled = true;
        this.headerCheckbox.checked = false;
        // Force update the checkbox component
        if (this.headerCheckbox.writeValue) {
          this.headerCheckbox.writeValue(false);
        }
        if (this.headerCheckbox.cd) {
          this.headerCheckbox.cd.detectChanges();
        }
      }
    } else {
      // Enable when there are selectable items
      
      // Check how many selectable items are selected
      const selectedCount = selectableItems.filter(item =>
        this.table.selection?.some(selected => this.equals(item, selected))
      ).length;
      
      const allSelected = selectedCount === selectableItems.length && selectedCount > 0;
      
      if (this.headerCheckbox) {
        this.headerCheckbox.disabled = false;
        this.headerCheckbox.checked = allSelected;
        
        // Force update the checkbox component with the correct value
        if (this.headerCheckbox.writeValue) {
          this.headerCheckbox.writeValue(allSelected);
        }
        
        // Handle model update
        if (this.headerCheckbox.model !== allSelected) {
          this.headerCheckbox.model = allSelected;
        }
        
        // Emit change event if needed
        if (this.headerCheckbox.onChange && this.headerCheckbox.onChange.observers?.length > 0) {
          this.headerCheckbox.onChange.emit(allSelected);
        }
        
        // Force Angular change detection on the checkbox
        if (this.headerCheckbox.cd) {
          this.headerCheckbox.cd.detectChanges();
        }
      }
    }
    
    // Force table change detection
    if (this.cdr) {
      this.cdr.detectChanges();
    }
  }

  private cleanSelection() {
    if (!this.table.selection || !Array.isArray(this.table.selection)) return;
    
    // Remove previously selected items from current selection
    const cleaned = this.table.selection.filter(selected => 
      this.isSelectable(selected)
    );
    
    // Remove duplicates
    const uniqueCleaned: any[] = [];
    const seen = new Set<string>();
    
    cleaned.forEach(item => {
      const key = `${item.entityType}_${item.entityId}`;
      if (!seen.has(key)) {
        seen.add(key);
        uniqueCleaned.push(item);
      }
    });
    
    if (uniqueCleaned.length !== this.table.selection.length) {
      this.table.selection = uniqueCleaned;
      this.updateSelectionKeys();
    }
  }

  private isSelectable(item: any): boolean {
    if (!this.previouslySelected || this.previouslySelected.length === 0) {
      return true;
    }
    // Item is selectable if NOT in previously selected list
    return !this.previouslySelected.some(selected => this.equals(item, selected));
  }

  private updateSelectionKeys() {
    // Update PrimeNG's internal selection tracking
    const keys: any = {};
    if (Array.isArray(this.table.selection)) {
      this.table.selection.forEach(item => {
        if (item.entityId !== undefined && item.entityType !== undefined) {
          const compositeKey = `${item.entityType}_${item.entityId}`;
          keys[compositeKey] = 1;
        }
      });
    }
    (this.table as any).selectionKeys = keys;
  }

  private equals(a: any, b: any): boolean {
    if (a === b) return true;
    if (!a || !b) return false;
    
    if (a.entityId !== undefined && a.entityType !== undefined &&
        b.entityId !== undefined && b.entityType !== undefined) {
      return a.entityId === b.entityId && a.entityType === b.entityType;
    }
    
    return false;
  }
}