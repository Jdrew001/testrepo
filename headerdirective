import { Directive, Host, OnInit, OnDestroy, AfterViewInit, ElementRef } from '@angular/core';
import { Table } from 'primeng/table';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, OnDestroy, AfterViewInit {
  
  private interval?: any;

  constructor(
    @Host() private table: Table,
    private el: ElementRef
  ) {}

  ngOnInit() {
    // Override toggleAll to handle disabled items
    (this.table as any).toggleAll = () => this.toggleAll();
  }

  ngAfterViewInit() {
    // Keep header enabled
    this.interval = setInterval(() => this.fixHeader(), 100);
    
    // Fix after pagination/sort/filter
    [this.table.onPage, this.table.onSort, this.table.onFilter].forEach(e => {
      e?.subscribe(() => setTimeout(() => this.fixHeader(), 100));
    });
  }

  ngOnDestroy() {
    if (this.interval) clearInterval(this.interval);
  }

  private fixHeader() {
    const header = this.getHeader();
    if (!header) return;

    const hasData = (this.table.value || []).length > 0;
    
    // Enable if data exists
    if (hasData) {
      header.disabled = false;
      const wrapper = header.closest('.p-checkbox');
      if (wrapper) {
        wrapper.classList.remove('p-checkbox-disabled', 'p-disabled');
      }
    }
    
    this.updateHeaderState();
  }

  private toggleAll() {
    const allData = this.table.value || [];
    if (!allData.length) return;

    const enabledItems = this.getEnabledItems();
    const allSelected = enabledItems.every(item => this.isSelected(item));

    // Toggle selection
    this.table.selection = allSelected ? [] : [...enabledItems];
    
    if (this.table.selectionChange) {
      this.table.selectionChange.emit(this.table.selection);
    }

    setTimeout(() => {
      this.updateHeaderState();
      this.updateBodyCheckboxes();
    }, 0);
  }

  private getEnabledItems(): any[] {
    const allData = this.table.value || [];
    const currentPage = this.getCurrentPage();
    const bodyCheckboxes = this.getBodyCheckboxes();
    
    // Find disabled items on current page
    const disabledKeys = new Set<string>();
    currentPage.forEach((item, i) => {
      if (bodyCheckboxes[i]?.disabled) {
        disabledKeys.add(this.getKey(item));
      }
    });

    // Return all items except disabled ones
    return allData.filter(item => !disabledKeys.has(this.getKey(item)));
  }

  private getCurrentPage(): any[] {
    if (this.table.paginator && this.table.rows) {
      const first = this.table.first || 0;
      return (this.table.value || []).slice(first, first + this.table.rows);
    }
    return this.table.value || [];
  }

  private updateHeaderState() {
    const header = this.getHeader();
    if (!header) return;

    const enabled = this.getEnabledItems();
    const selected = this.table.selection?.length || 0;

    if (selected === 0) {
      header.checked = false;
      header.indeterminate = false;
    } else if (selected === enabled.length && enabled.length > 0) {
      header.checked = true;
      header.indeterminate = false;
    } else {
      header.checked = false;
      header.indeterminate = true;
    }
  }

  private updateBodyCheckboxes() {
    const currentPage = this.getCurrentPage();
    const checkboxes = this.getBodyCheckboxes();
    
    checkboxes.forEach((cb, i) => {
      if (i < currentPage.length && !cb.disabled) {
        cb.checked = this.isSelected(currentPage[i]);
      }
    });
  }

  private isSelected(item: any): boolean {
    if (!this.table.selection) return false;
    return Array.isArray(this.table.selection) 
      ? this.table.selection.some(s => this.equals(item, s))
      : this.equals(item, this.table.selection);
  }

  private equals(a: any, b: any): boolean {
    if (a === b) return true;
    if (!a || !b) return false;
    
    // Handle entityId + entityType composite key
    if (a.entityId !== undefined && a.entityType !== undefined) {
      return a.entityId === b.entityId && a.entityType === b.entityType;
    }
    
    // Check common ID fields
    for (const field of ['id', 'ID', '_id']) {
      if (a[field] !== undefined && b[field] !== undefined) {
        return a[field] === b[field];
      }
    }
    return false;
  }

  private getKey(item: any): string {
    if (item.entityId !== undefined && item.entityType !== undefined) {
      return `${item.entityType}_${item.entityId}`;
    }
    for (const field of ['id', 'ID', '_id']) {
      if (item[field] !== undefined) return String(item[field]);
    }
    return JSON.stringify(item);
  }

  private getHeader(): HTMLInputElement | null {
    return this.el.nativeElement.querySelector('thead input[type="checkbox"]');
  }

  private getBodyCheckboxes(): HTMLInputElement[] {
    return Array.from(this.el.nativeElement.querySelectorAll('tbody input[type="checkbox"]'));
  }
}
