import { Directive, Host, OnInit, OnDestroy, AfterViewInit, ElementRef, Renderer2, NgZone } from '@angular/core';
import { Table } from 'primeng/table';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, OnDestroy, AfterViewInit {
  
  private destroy$ = new Subject<void>();
  private headerCheckboxInterval?: any;
  private originalToggleAllFn?: Function;
  private isProcessingToggle = false;

  constructor(
    @Host() private table: Table,
    private element: ElementRef,
    private renderer: Renderer2,
    private ngZone: NgZone
  ) {}

  ngOnInit() {
    // Store the original toggleAll function
    this.originalToggleAllFn = (this.table as any).toggleAll?.bind(this.table);
    
    // Override the toggleAll method to filter disabled items
    if ((this.table as any).toggleAll) {
      (this.table as any).toggleAll = (event: any) => {
        this.customToggleAll(event);
      };
    }

    // Monitor selection changes
    if (this.table.selectionChange) {
      this.table.selectionChange
        .pipe(takeUntil(this.destroy$))
        .subscribe(() => {
          if (!this.isProcessingToggle) {
            requestAnimationFrame(() => {
              this.cleanupDisabledFromSelection();
              this.updateHeaderCheckbox();
            });
          }
        });
    }
  }

  ngAfterViewInit() {
    // Initial setup after view is ready
    setTimeout(() => {
      this.initializeHeaderFix();
    }, 100);

    // Re-initialize after table operations
    this.setupTableEventHandlers();
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    
    if (this.headerCheckboxInterval) {
      clearInterval(this.headerCheckboxInterval);
    }

    // Restore original function if needed
    if (this.originalToggleAllFn && (this.table as any).toggleAll) {
      (this.table as any).toggleAll = this.originalToggleAllFn;
    }
  }

  private setupTableEventHandlers() {
    // Re-initialize after pagination
    if (this.table.onPage) {
      this.table.onPage.pipe(takeUntil(this.destroy$)).subscribe(() => {
        // Use longer timeout for page changes to ensure DOM is ready
        setTimeout(() => {
          this.initializeHeaderFix();
        }, 200);
      });
    }

    // Re-initialize after sorting
    if (this.table.onSort) {
      this.table.onSort.pipe(takeUntil(this.destroy$)).subscribe(() => {
        setTimeout(() => {
          this.initializeHeaderFix();
        }, 150);
      });
    }

    // Re-initialize after filtering
    if (this.table.onFilter) {
      this.table.onFilter.pipe(takeUntil(this.destroy$)).subscribe(() => {
        setTimeout(() => {
          this.initializeHeaderFix();
        }, 150);
      });
    }

    // Handle lazy loading
    if (this.table.onLazyLoad) {
      this.table.onLazyLoad.pipe(takeUntil(this.destroy$)).subscribe(() => {
        setTimeout(() => {
          this.initializeHeaderFix();
        }, 200);
      });
    }
  }

  private initializeHeaderFix() {
    this.enforceDisabledCheckboxes();
    this.cleanupDisabledFromSelection();
    this.updateHeaderCheckbox();
    this.startHeaderMonitoring();
  }

  private startHeaderMonitoring() {
    // Clear any existing interval
    if (this.headerCheckboxInterval) {
      clearInterval(this.headerCheckboxInterval);
    }

    // Monitor header checkbox state
    this.ngZone.runOutsideAngular(() => {
      this.headerCheckboxInterval = setInterval(() => {
        const headerEl = this.getHeaderCheckboxElement();
        if (headerEl) {
          const checkbox = headerEl.querySelector('input[type="checkbox"]');
          if (checkbox && (checkbox as HTMLInputElement).disabled) {
            this.ngZone.run(() => {
              this.renderer.setProperty(checkbox, 'disabled', false);
              this.updateHeaderVisualState();
            });
          }
        }
      }, 100);
    });
  }

  private customToggleAll(event: any) {
    this.isProcessingToggle = true;

    // Get ALL data (not just current page)
    const allData = this.table.filteredValue || this.table.value || [];
    
    // We need to determine which items across ALL pages are enabled
    // For items not on current page, we'll assume they're enabled unless we have info otherwise
    const currentPageData = this.getCurrentPageData();
    const currentPageCheckboxes = this.getBodyCheckboxes();
    
    // Build a map of disabled items from current page
    const disabledItemsMap = new Map();
    currentPageData.forEach((item, index) => {
      if (index < currentPageCheckboxes.length && currentPageCheckboxes[index].disabled) {
        // Mark this item as disabled
        disabledItemsMap.set(this.getItemKey(item), true);
      }
    });

    // Filter all data to exclude disabled items
    const allEnabledItems = allData.filter(item => {
      const itemKey = this.getItemKey(item);
      return !disabledItemsMap.has(itemKey);
    });

    // Check if all enabled items are currently selected
    const allEnabledSelected = allEnabledItems.every(item => this.isItemSelected(item));

    // Toggle selection
    if (!allEnabledSelected) {
      // Select all enabled items across ALL pages
      this.table.selection = [...allEnabledItems];
    } else {
      // Deselect all
      this.table.selection = [];
    }
    
    // Emit change
    if (this.table.selectionChange) {
      this.table.selectionChange.emit(this.table.selection);
    }

    // Update visual state
    this.updateTableCheckboxes();
    
    setTimeout(() => {
      this.updateHeaderCheckbox();
      this.isProcessingToggle = false;
    }, 50);
  }

  private getItemKey(item: any): string {
    if (this.table.dataKey) {
      const key = this.resolveFieldData(item, this.table.dataKey);
      return String(key);
    }
    
    // Try common ID fields
    const idProps = ['id', 'ID', '_id', 'key', 'uuid', 'code'];
    for (const prop of idProps) {
      if (item[prop] !== undefined) {
        return String(item[prop]);
      }
    }
    
    // Fallback to JSON string (not ideal but works)
    return JSON.stringify(item);
  }

  private getCurrentPageData(): any[] {
    // For paginated tables
    if (this.table.paginator && this.table.rows) {
      const first = this.table.first || 0;
      const rows = this.table.rows;
      return (this.table.filteredValue || this.table.value || []).slice(first, first + rows);
    }
    
    // For non-paginated tables
    return this.table.filteredValue || this.table.value || [];
  }

  private enforceDisabledCheckboxes() {
    const checkboxes = this.getBodyCheckboxes();
    const currentData = this.getCurrentPageData();
    
    checkboxes.forEach((checkbox, index) => {
      if (index < currentData.length) {
        const item = currentData[index];
        
        // Check if this row should be disabled based on your logic
        // This is where you'd implement your business logic for disabled rows
        const shouldBeDisabled = this.isRowDisabled(item, index);
        
        if (shouldBeDisabled) {
          // Disable the checkbox
          this.renderer.setProperty(checkbox, 'disabled', true);
          this.renderer.setProperty(checkbox, 'checked', false);
          
          // Update visual state
          const wrapper = checkbox.closest('.p-checkbox');
          if (wrapper) {
            this.renderer.addClass(wrapper, 'p-checkbox-disabled');
            this.renderer.addClass(wrapper, 'p-disabled');
            
            const box = wrapper.querySelector('.p-checkbox-box');
            if (box) {
              this.renderer.addClass(box, 'p-disabled');
              this.renderer.removeClass(box, 'p-highlight');
            }
          }
        }
      }
    });
  }

  private isRowDisabled(item: any, index: number): boolean {
    // Check if there's a custom disable function set on the table
    // You might need to implement this based on your specific requirements
    // For example, you might check a property on the item:
    
    if (item.disabled !== undefined) {
      return item.disabled;
    }
    
    if (item.selectable !== undefined) {
      return !item.selectable;
    }
    
    // You can add your custom logic here
    // For example, check if the current user can select this item
    
    return false;
  }

  private cleanupDisabledFromSelection() {
    if (!this.table.selection || !Array.isArray(this.table.selection)) {
      return;
    }

    const currentData = this.getCurrentPageData();
    const currentPageCheckboxes = this.getBodyCheckboxes();
    
    // Build list of disabled items on current page
    const disabledItems: any[] = [];
    currentData.forEach((item, index) => {
      if (index < currentPageCheckboxes.length && currentPageCheckboxes[index].disabled) {
        disabledItems.push(item);
      }
    });
    
    // Remove disabled items from selection
    const cleanedSelection = this.table.selection.filter(selectedItem => {
      // Check if this selected item is one of the disabled items on current page
      return !disabledItems.some(disabledItem => this.itemsEqual(selectedItem, disabledItem));
    });

    if (cleanedSelection.length !== this.table.selection.length) {
      this.table.selection = cleanedSelection;
      if (this.table.selectionChange) {
        this.table.selectionChange.emit(cleanedSelection);
      }
    }
  }

  private updateTableCheckboxes() {
    const checkboxes = this.getBodyCheckboxes();
    const currentData = this.getCurrentPageData();
    
    checkboxes.forEach((checkbox, index) => {
      if (index < currentData.length) {
        const item = currentData[index];
        const isSelected = this.isItemSelected(item);
        
        if (checkbox.disabled) {
          // Force disabled checkboxes to be unchecked
          this.renderer.setProperty(checkbox, 'checked', false);
        } else {
          // Update enabled checkboxes
          this.renderer.setProperty(checkbox, 'checked', isSelected);
        }
        
        // Update visual state through PrimeNG's classes
        const wrapper = checkbox.closest('.p-checkbox');
        if (wrapper) {
          const box = wrapper.querySelector('.p-checkbox-box');
          if (box) {
            if (isSelected && !checkbox.disabled) {
              this.renderer.addClass(box, 'p-highlight');
            } else {
              this.renderer.removeClass(box, 'p-highlight');
            }
          }
        }
      }
    });
  }

  private updateHeaderCheckbox() {
    const headerEl = this.getHeaderCheckboxElement();
    if (!headerEl) return;

    const checkbox = headerEl.querySelector('input[type="checkbox"]') as HTMLInputElement;
    if (!checkbox) return;

    // Force enable
    this.renderer.setProperty(checkbox, 'disabled', false);

    // For header state, we need to consider ALL pages, not just current
    const allData = this.table.filteredValue || this.table.value || [];
    
    if (allData.length === 0) {
      // No data at all
      this.renderer.setProperty(checkbox, 'checked', false);
      this.renderer.setProperty(checkbox, 'indeterminate', false);
      this.updateHeaderVisualState();
      return;
    }

    // Get info about current page disabled items
    const currentPageData = this.getCurrentPageData();
    const currentPageCheckboxes = this.getBodyCheckboxes();
    const currentPageDisabledCount = currentPageCheckboxes.filter(cb => cb.disabled).length;
    
    // For items not on current page, assume they're enabled
    // This is a limitation - we can't know the disabled state of items on other pages
    const currentPageEnabledCount = currentPageData.length - currentPageDisabledCount;
    const otherPagesCount = allData.length - currentPageData.length;
    const estimatedTotalEnabled = currentPageEnabledCount + otherPagesCount;

    // Count selected items
    let selectedCount = 0;
    if (this.table.selection && Array.isArray(this.table.selection)) {
      selectedCount = this.table.selection.length;
    }

    // Update checkbox state based on selection across ALL data
    if (selectedCount === 0) {
      this.renderer.setProperty(checkbox, 'checked', false);
      this.renderer.setProperty(checkbox, 'indeterminate', false);
    } else if (selectedCount >= estimatedTotalEnabled) {
      // All enabled items (that we know of) are selected
      this.renderer.setProperty(checkbox, 'checked', true);
      this.renderer.setProperty(checkbox, 'indeterminate', false);
    } else {
      // Partial selection
      this.renderer.setProperty(checkbox, 'checked', false);
      this.renderer.setProperty(checkbox, 'indeterminate', true);
    }

    this.updateHeaderVisualState();
  }

  private updateHeaderVisualState() {
    const headerEl = this.getHeaderCheckboxElement();
    if (!headerEl) return;

    const checkbox = headerEl.querySelector('input[type="checkbox"]') as HTMLInputElement;
    if (!checkbox) return;

    const wrapper = headerEl.querySelector('.p-checkbox');
    if (wrapper) {
      this.renderer.removeClass(wrapper, 'p-checkbox-disabled');
      this.renderer.removeClass(wrapper, 'p-disabled');
      
      const box = wrapper.querySelector('.p-checkbox-box');
      if (box) {
        this.renderer.removeClass(box, 'p-disabled');
        
        // Update highlight based on state
        if (checkbox.checked || checkbox.indeterminate) {
          this.renderer.addClass(box, 'p-highlight');
        } else {
          this.renderer.removeClass(box, 'p-highlight');
        }
        
        // Update icon
        const icon = box.querySelector('.p-checkbox-icon');
        if (icon) {
          // Clear existing classes
          this.renderer.setAttribute(icon, 'class', 'p-checkbox-icon');
          
          if (checkbox.checked) {
            this.renderer.addClass(icon, 'pi');
            this.renderer.addClass(icon, 'pi-check');
          } else if (checkbox.indeterminate) {
            this.renderer.addClass(icon, 'pi');
            this.renderer.addClass(icon, 'pi-minus');
          } else {
            this.renderer.addClass(icon, 'pi');
          }
        }
      }
    }
  }

  private getHeaderCheckboxElement(): HTMLElement | null {
    return this.element.nativeElement.querySelector('thead p-tableheadercheckbox') ||
           this.element.nativeElement.querySelector('thead .p-selection-column');
  }

  private getBodyCheckboxes(): HTMLInputElement[] {
    const checkboxes = this.element.nativeElement.querySelectorAll(
      'tbody .p-selection-column input[type="checkbox"], tbody p-tablecheckbox input[type="checkbox"]'
    );
    return Array.from(checkboxes);
  }

  private isItemSelected(item: any): boolean {
    if (!this.table.selection) return false;
    
    if (Array.isArray(this.table.selection)) {
      return this.table.selection.some(selectedItem => 
        this.itemsEqual(item, selectedItem)
      );
    }
    
    return this.itemsEqual(item, this.table.selection);
  }

  private itemsEqual(item1: any, item2: any): boolean {
    if (item1 === item2) return true;
    if (!item1 || !item2) return false;
    
    if (this.table.dataKey) {
      const key1 = this.resolveFieldData(item1, this.table.dataKey);
      const key2 = this.resolveFieldData(item2, this.table.dataKey);
      if (key1 !== undefined && key2 !== undefined) {
        return key1 === key2;
      }
    }
    
    const idProps = ['id', 'ID', '_id', 'key', 'uuid', 'code'];
    for (const prop of idProps) {
      if (item1[prop] !== undefined && item2[prop] !== undefined) {
        return item1[prop] === item2[prop];
      }
    }
    
    return false;
  }

  private resolveFieldData(data: any, field: string): any {
    if (!data || !field) return undefined;
    
    if (field.indexOf('.') === -1) {
      return data[field];
    }
    
    const fields = field.split('.');
    let value = data;
    for (const f of fields) {
      if (value == null) return undefined;
      value = value[f];
    }
    return value;
  }
}
