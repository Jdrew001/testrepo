import { Directive, Host, OnInit, OnDestroy, AfterViewInit } from '@angular/core';
import { Table } from 'primeng/table';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

@Directive({
  selector: '[appSelectionFix]'
})
export class SelectionFixDirective implements OnInit, OnDestroy, AfterViewInit {
  
  private destroy$ = new Subject<void>();
  private checkInterval?: any;

  constructor(@Host() private table: Table) {}

  ngOnInit() {
    // Listen to header checkbox toggle events
    if (this.table.onHeaderCheckboxToggle) {
      this.table.onHeaderCheckboxToggle.pipe(takeUntil(this.destroy$)).subscribe((event) => {
        // Prevent default behavior
        event.originalEvent?.preventDefault();
        event.originalEvent?.stopPropagation();
        
        // Handle our custom toggle
        this.handleHeaderToggle(event.checked);
      });
    }

    // Clean selection when it changes
    if (this.table.selectionChange) {
      this.table.selectionChange.pipe(takeUntil(this.destroy$)).subscribe(() => {
        this.removeDisabledFromSelection();
        this.updateHeaderState();
      });
    }
  }

  ngAfterViewInit() {
    // Initial setup
    setTimeout(() => {
      this.removeDisabledFromSelection();
      this.updateHeaderState();
    }, 0);

    // Keep header enabled
    this.checkInterval = setInterval(() => {
      this.ensureHeaderEnabled();
    }, 100);

    // Update after table changes
    [this.table.onPage, this.table.onSort, this.table.onFilter].forEach(event => {
      if (event) {
        event.pipe(takeUntil(this.destroy$)).subscribe(() => {
          setTimeout(() => {
            this.removeDisabledFromSelection();
            this.updateHeaderState();
          }, 0);
        });
      }
    });
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
    }
  }

  private handleHeaderToggle(checked: boolean) {
    const data = this.getData();
    if (!data || data.length === 0) return;

    // Get enabled items only
    const enabledItems = data.filter(item => !this.isDisabled(item));
    
    if (checked) {
      // Select all enabled items
      this.table.selection = [...enabledItems];
    } else {
      // Deselect all
      this.table.selection = [];
    }

    // Emit the selection change
    if (this.table.selectionChange) {
      this.table.selectionChange.emit(this.table.selection);
    }

    // Update selection keys for PrimeNG internal state
    this.updateSelectionKeys();
  }

  private getData(): any[] {
    return this.table.filteredValue || this.table.value || [];
  }

  private isDisabled(item: any): boolean {
    // Your business logic for disabled items
    return item.disabled === true || item.selectable === false;
  }

  private removeDisabledFromSelection() {
    if (!this.table.selection || !Array.isArray(this.table.selection)) return;

    const data = this.getData();
    const enabledItems = data.filter(item => !this.isDisabled(item));
    
    // Filter out disabled items from selection
    const cleaned = this.table.selection.filter(selected =>
      enabledItems.some(enabled => this.equals(selected, enabled))
    );

    if (cleaned.length !== this.table.selection.length) {
      this.table.selection = cleaned;
      this.updateSelectionKeys();
    }
  }

  private updateSelectionKeys() {
    // Update PrimeNG's internal selection keys
    if (this.table.dataKey) {
      const keys: any = {};
      if (this.table.selection && Array.isArray(this.table.selection)) {
        this.table.selection.forEach(item => {
          const key = this.resolveFieldData(item, this.table.dataKey);
          if (key) {
            keys[key] = 1;
          }
        });
      }
      (this.table as any).selectionKeys = keys;
    }
  }

  private ensureHeaderEnabled() {
    // Keep header checkbox enabled if there's data
    const hasData = this.getData().length > 0;
    
    if (hasData && (this.table as any).selectAllCheckbox) {
      const headerCheckbox = (this.table as any).selectAllCheckbox;
      if (headerCheckbox && headerCheckbox.disabled) {
        headerCheckbox.disabled = false;
      }
    }
  }

  private updateHeaderState() {
    // Update header checkbox checked/indeterminate state
    const data = this.getData();
    const enabledItems = data.filter(item => !this.isDisabled(item));
    const selectedCount = this.table.selection?.length || 0;
    
    // Set the allChecked property that PrimeNG uses
    if (selectedCount === 0) {
      (this.table as any).allChecked = false;
    } else if (selectedCount === enabledItems.length && enabledItems.length > 0) {
      (this.table as any).allChecked = true;
    } else {
      (this.table as any).allChecked = false;
    }
  }

  private equals(a: any, b: any): boolean {
    if (a === b) return true;
    if (!a || !b) return false;
    
    // Handle composite key (entityId + entityType)
    if (a.entityId !== undefined && a.entityType !== undefined &&
        b.entityId !== undefined && b.entityType !== undefined) {
      return a.entityId === b.entityId && a.entityType === b.entityType;
    }
    
    // Use table's dataKey if set
    if (this.table.dataKey) {
      const key1 = this.resolveFieldData(a, this.table.dataKey);
      const key2 = this.resolveFieldData(b, this.table.dataKey);
      return key1 === key2;
    }
    
    // Check common ID fields
    for (const field of ['id', 'ID', '_id']) {
      if (a[field] !== undefined && b[field] !== undefined) {
        return a[field] === b[field];
      }
    }
    
    return false;
  }

  private resolveFieldData(data: any, field: string): any {
    if (!field || field.indexOf('.') === -1) {
      return data[field];
    }
    
    const fields = field.split('.');
    let value = data;
    for (const f of fields) {
      if (value == null) return null;
      value = value[f];
    }
    return value;
  }
}
